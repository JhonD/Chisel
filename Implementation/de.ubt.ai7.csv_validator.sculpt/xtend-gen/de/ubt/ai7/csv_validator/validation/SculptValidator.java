/**
 * generated by Xtext
 */
package de.ubt.ai7.csv_validator.validation;

import com.google.common.base.Objects;
import de.ubt.ai7.csv_validator.library.parser.Parser;
import de.ubt.ai7.csv_validator.library.parser.impl.ParserProviderImpl;
import de.ubt.ai7.csv_validator.sculpt.AbstractToken;
import de.ubt.ai7.csv_validator.sculpt.AtomicType;
import de.ubt.ai7.csv_validator.sculpt.CompoundType;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypePrimitive;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypeSpecifier;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionComparison;
import de.ubt.ai7.csv_validator.sculpt.ListType;
import de.ubt.ai7.csv_validator.sculpt.ListTypeSpecifier;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionComparison;
import de.ubt.ai7.csv_validator.sculpt.Sculpt;
import de.ubt.ai7.csv_validator.sculpt.SculptPackage;
import de.ubt.ai7.csv_validator.sculpt.TLLoop;
import de.ubt.ai7.csv_validator.sculpt.TLLoopMode;
import de.ubt.ai7.csv_validator.sculpt.TLOutput;
import de.ubt.ai7.csv_validator.sculpt.Token;
import de.ubt.ai7.csv_validator.sculpt.TransformationProgram;
import de.ubt.ai7.csv_validator.sculpt.Type;
import de.ubt.ai7.csv_validator.sculpt.TypeSpecifier;
import de.ubt.ai7.csv_validator.validation.AbstractSculptValidator;
import de.ubt.ai7.csv_validator.validation.ValidationUtil;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Pattern;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SculptValidator extends AbstractSculptValidator {
  @Check
  public void checkSchemaElementNameIsUnique(final Sculpt schema) {
    final HashSet<String> usedNames = new HashSet<String>();
    final List<AbstractToken> tokens = EcoreUtil2.<AbstractToken>getAllContentsOfType(schema, AbstractToken.class);
    for (final AbstractToken tok : tokens) {
      boolean _contains = usedNames.contains(tok.getName());
      if (_contains) {
        this.error("Names have to be globally unique", tok, SculptPackage.Literals.ABSTRACT_TOKEN__NAME);
      } else {
        usedNames.add(tok.getName());
      }
    }
  }
  
  @Check
  public void checkNodeExpressionComparison(final NodeExpressionComparison ne) {
    this.checkTypeSpecifiers(ne.getType(), ne.getTypeSpecifier());
  }
  
  @Check
  public void checkContentExpressionComparison(final ContentExpressionComparison ce) {
    if ((Objects.equal(ce.getValue(), null) && Objects.equal(ce.getPath(), null))) {
      this.error("Value or path to region expected", ce, null);
    }
    this.checkTypeSpecifiers(ce.getType(), ce.getTypeSpecifier());
  }
  
  public Type checkTypeSpecifiers(final Type topType, final EList<TypeSpecifier> path) {
    Type type = topType;
    boolean _equals = Objects.equal(path, null);
    if (_equals) {
      return null;
    }
    for (final TypeSpecifier typeSpec : path) {
      if ((type instanceof AtomicType)) {
        if ((typeSpec instanceof CompoundTypeSpecifier)) {
          String _name = ((AtomicType)type).getName();
          String _plus = ("The atomic type " + _name);
          String _plus_1 = (_plus + " cannot be subdivided");
          this.error(_plus_1, typeSpec, 
            SculptPackage.Literals.COMPOUND_TYPE_SPECIFIER__SUBTYPE);
          return null;
        } else {
          String _name_1 = ((AtomicType)type).getName();
          String _plus_2 = ("The atomic type " + _name_1);
          String _plus_3 = (_plus_2 + " cannot be subdivided");
          this.error(_plus_3, typeSpec, 
            SculptPackage.Literals.LIST_TYPE_SPECIFIER__INDEX);
          return null;
        }
      } else {
        if ((typeSpec instanceof ListTypeSpecifier)) {
          final int index = ((ListTypeSpecifier)typeSpec).getIndex();
          if ((type instanceof ListType)) {
            if ((((!Objects.equal(((ListType)type).getMaxElements(), null)) && ((((ListType)type).getMaxElements()).intValue() >= 0)) && ((((ListType)type).getMaxElements()).intValue() <= index))) {
              String _name_2 = ((ListType)type).getName();
              String _plus_4 = ("Index out of bounds for type " + _name_2);
              this.error(_plus_4, typeSpec, 
                SculptPackage.Literals.LIST_TYPE_SPECIFIER__INDEX);
              return null;
            }
            type = ((ListType)type).getBase();
          } else {
            String _name_3 = type.getName();
            String _plus_5 = ("Type " + _name_3);
            String _plus_6 = (_plus_5 + " is not a list");
            this.error(_plus_6, typeSpec, 
              SculptPackage.Literals.LIST_TYPE_SPECIFIER__INDEX);
            return null;
          }
        } else {
          if ((typeSpec instanceof CompoundTypeSpecifier)) {
            if ((type instanceof CompoundType)) {
              final Type subtype = ((CompoundTypeSpecifier)typeSpec).getSubtype();
              final int subtypeOffset = ((CompoundTypeSpecifier)typeSpec).getIndex();
              int _childIndex = ValidationUtil.getChildIndex(((CompoundType)type).getPrimitives(), subtype, subtypeOffset);
              boolean _equals_1 = (_childIndex == (-1));
              if (_equals_1) {
                if ((subtypeOffset == 0)) {
                  String _name_4 = ((CompoundType)type).getName();
                  String _plus_7 = ("Type " + _name_4);
                  String _plus_8 = (_plus_7 + " does not contain such a type");
                  this.error(_plus_8, typeSpec, 
                    SculptPackage.Literals.COMPOUND_TYPE_SPECIFIER__SUBTYPE);
                } else {
                  String _name_5 = ((CompoundType)type).getName();
                  String _plus_9 = ("Type " + _name_5);
                  String _plus_10 = (_plus_9 + " does not contain that type such often");
                  this.error(_plus_10, typeSpec, 
                    SculptPackage.Literals.COMPOUND_TYPE_SPECIFIER__INDEX);
                }
                return null;
              }
              type = subtype;
            } else {
              String _name_6 = type.getName();
              String _plus_11 = ("Type " + _name_6);
              String _plus_12 = (_plus_11 + " is not a compound type");
              this.error(_plus_12, typeSpec, 
                SculptPackage.Literals.COMPOUND_TYPE_SPECIFIER__SUBTYPE);
              return null;
            }
          }
        }
      }
    }
    return type;
  }
  
  public boolean checkInterval(final Integer minimum, final Integer maximum) {
    return (((maximum).intValue() == (-1)) || (minimum.compareTo(maximum) <= 0));
  }
  
  @Check
  public void checkListType(final ListType type) {
    if (((!Objects.equal(type.getMinElements(), null)) && ((type.getMinElements()).intValue() < 0))) {
      this.error("Value must be non-negative", type, SculptPackage.Literals.LIST_TYPE__MIN_ELEMENTS);
    }
    if (((!Objects.equal(type.getMaxElements(), null)) && (((type.getMaxElements()).intValue() < (-1)) || ((type.getMaxElements()).intValue() == 0)))) {
      this.error("Value must be positive", type, SculptPackage.Literals.LIST_TYPE__MAX_ELEMENTS);
    }
    boolean _checkInterval = this.checkInterval(type.getMinElements(), type.getMaxElements());
    boolean _not = (!_checkInterval);
    if (_not) {
      this.error("Conflicts with other bound", type, SculptPackage.Literals.LIST_TYPE__MAX_ELEMENTS);
    }
  }
  
  public void testParserParameters(final Parser<?> parser, final AtomicType type) {
    try {
      parser.setDecimalChar(type.getDecimalChar());
    } catch (final Throwable _t) {
      if (_t instanceof IllegalArgumentException) {
        final IllegalArgumentException e = (IllegalArgumentException)_t;
        String _message = e.getMessage();
        String _plus = ("Invalid value: " + _message);
        this.error(_plus, type, SculptPackage.Literals.ATOMIC_TYPE__DECIMAL_CHAR);
      } else if (_t instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_1 = (UnsupportedOperationException)_t;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__DECIMAL_CHAR);
      } else if (_t instanceof Exception) {
        final Exception e_2 = (Exception)_t;
        this.error(e_2.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__DECIMAL_CHAR);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    try {
      parser.setGroupChar(type.getGroupChar());
    } catch (final Throwable _t_1) {
      if (_t_1 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_3 = (IllegalArgumentException)_t_1;
        String _message_1 = e_3.getMessage();
        String _plus_1 = ("Invalid value: " + _message_1);
        this.error(_plus_1, type, SculptPackage.Literals.ATOMIC_TYPE__GROUP_CHAR);
      } else if (_t_1 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_4 = (UnsupportedOperationException)_t_1;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__GROUP_CHAR);
      } else if (_t_1 instanceof Exception) {
        final Exception e_5 = (Exception)_t_1;
        this.error(e_5.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__GROUP_CHAR);
      } else {
        throw Exceptions.sneakyThrow(_t_1);
      }
    }
    try {
      parser.setFormat(type.getFormat());
    } catch (final Throwable _t_2) {
      if (_t_2 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_6 = (IllegalArgumentException)_t_2;
        String _message_2 = e_6.getMessage();
        String _plus_2 = ("Invalid value: " + _message_2);
        this.error(_plus_2, type, SculptPackage.Literals.ATOMIC_TYPE__FORMAT);
      } else if (_t_2 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_7 = (UnsupportedOperationException)_t_2;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__FORMAT);
      } else if (_t_2 instanceof Exception) {
        final Exception e_8 = (Exception)_t_2;
        this.error(e_8.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__FORMAT);
      } else {
        throw Exceptions.sneakyThrow(_t_2);
      }
    }
    try {
      parser.setLength(type.getLength());
    } catch (final Throwable _t_3) {
      if (_t_3 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_9 = (IllegalArgumentException)_t_3;
        String _message_3 = e_9.getMessage();
        String _plus_3 = ("Invalid value: " + _message_3);
        this.error(_plus_3, type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
      } else if (_t_3 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_10 = (UnsupportedOperationException)_t_3;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
      } else if (_t_3 instanceof Exception) {
        final Exception e_11 = (Exception)_t_3;
        this.error(e_11.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
      } else {
        throw Exceptions.sneakyThrow(_t_3);
      }
    }
    try {
      parser.setMinLength(type.getMinLength());
    } catch (final Throwable _t_4) {
      if (_t_4 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_12 = (IllegalArgumentException)_t_4;
        String _message_4 = e_12.getMessage();
        String _plus_4 = ("Invalid value: " + _message_4);
        this.error(_plus_4, type, SculptPackage.Literals.ATOMIC_TYPE__MIN_LENGTH);
      } else if (_t_4 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_13 = (UnsupportedOperationException)_t_4;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MIN_LENGTH);
      } else if (_t_4 instanceof Exception) {
        final Exception e_14 = (Exception)_t_4;
        this.error(e_14.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MIN_LENGTH);
      } else {
        throw Exceptions.sneakyThrow(_t_4);
      }
    }
    try {
      parser.setMaxLength(type.getMaxLength());
    } catch (final Throwable _t_5) {
      if (_t_5 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_15 = (IllegalArgumentException)_t_5;
        String _message_5 = e_15.getMessage();
        String _plus_5 = ("Invalid value: " + _message_5);
        this.error(_plus_5, type, SculptPackage.Literals.ATOMIC_TYPE__MAX_LENGTH);
      } else if (_t_5 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_16 = (UnsupportedOperationException)_t_5;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MAX_LENGTH);
      } else if (_t_5 instanceof Exception) {
        final Exception e_17 = (Exception)_t_5;
        this.error(e_17.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MAX_LENGTH);
      } else {
        throw Exceptions.sneakyThrow(_t_5);
      }
    }
    try {
      parser.setMinimum(type.getMinimum());
    } catch (final Throwable _t_6) {
      if (_t_6 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_18 = (IllegalArgumentException)_t_6;
        String _message_6 = e_18.getMessage();
        String _plus_6 = ("Invalid value: " + _message_6);
        this.error(_plus_6, type, SculptPackage.Literals.ATOMIC_TYPE__MINIMUM);
      } else if (_t_6 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_19 = (UnsupportedOperationException)_t_6;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MINIMUM);
      } else if (_t_6 instanceof Exception) {
        final Exception e_20 = (Exception)_t_6;
        this.error(e_20.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MINIMUM);
      } else {
        throw Exceptions.sneakyThrow(_t_6);
      }
    }
    try {
      parser.setMinExclusive(type.getMinExclusive());
    } catch (final Throwable _t_7) {
      if (_t_7 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_21 = (IllegalArgumentException)_t_7;
        String _message_7 = e_21.getMessage();
        String _plus_7 = ("Invalid value: " + _message_7);
        this.error(_plus_7, type, SculptPackage.Literals.ATOMIC_TYPE__MIN_EXCLUSIVE);
      } else if (_t_7 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_22 = (UnsupportedOperationException)_t_7;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MIN_EXCLUSIVE);
      } else if (_t_7 instanceof Exception) {
        final Exception e_23 = (Exception)_t_7;
        this.error(e_23.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MIN_EXCLUSIVE);
      } else {
        throw Exceptions.sneakyThrow(_t_7);
      }
    }
    try {
      parser.setMaximum(type.getMaximum());
    } catch (final Throwable _t_8) {
      if (_t_8 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_24 = (IllegalArgumentException)_t_8;
        String _message_8 = e_24.getMessage();
        String _plus_8 = ("Invalid value: " + _message_8);
        this.error(_plus_8, type, SculptPackage.Literals.ATOMIC_TYPE__MAXIMUM);
      } else if (_t_8 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_25 = (UnsupportedOperationException)_t_8;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MAXIMUM);
      } else if (_t_8 instanceof Exception) {
        final Exception e_26 = (Exception)_t_8;
        this.error(e_26.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MAXIMUM);
      } else {
        throw Exceptions.sneakyThrow(_t_8);
      }
    }
    try {
      parser.setMaxExclusive(type.getMaxExclusive());
    } catch (final Throwable _t_9) {
      if (_t_9 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_27 = (IllegalArgumentException)_t_9;
        String _message_9 = e_27.getMessage();
        String _plus_9 = ("Invalid value: " + _message_9);
        this.error(_plus_9, type, SculptPackage.Literals.ATOMIC_TYPE__MAX_EXCLUSIVE);
      } else if (_t_9 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_28 = (UnsupportedOperationException)_t_9;
        this.error("Unsupported parameter", type, SculptPackage.Literals.ATOMIC_TYPE__MAX_EXCLUSIVE);
      } else if (_t_9 instanceof Exception) {
        final Exception e_29 = (Exception)_t_9;
        this.error(e_29.getLocalizedMessage(), type, SculptPackage.Literals.ATOMIC_TYPE__MAX_EXCLUSIVE);
      } else {
        throw Exceptions.sneakyThrow(_t_9);
      }
    }
    try {
      parser.setDefaultValue(type.getDefaultValue());
    } catch (final Throwable _t_10) {
      if (_t_10 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_30 = (IllegalArgumentException)_t_10;
        String _message_10 = e_30.getMessage();
        String _plus_10 = ("Invalid value: " + _message_10);
        this.error(_plus_10, type, SculptPackage.Literals.TYPE__DEFAULT_VALUE);
      } else if (_t_10 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_31 = (UnsupportedOperationException)_t_10;
        this.error("Unsupported parameter", type, SculptPackage.Literals.TYPE__DEFAULT_VALUE);
      } else if (_t_10 instanceof Exception) {
        final Exception e_32 = (Exception)_t_10;
        this.error(e_32.getLocalizedMessage(), type, SculptPackage.Literals.TYPE__DEFAULT_VALUE);
      } else {
        throw Exceptions.sneakyThrow(_t_10);
      }
    }
    try {
      parser.setEmptyValue(type.getEmptyValue());
    } catch (final Throwable _t_11) {
      if (_t_11 instanceof IllegalArgumentException) {
        final IllegalArgumentException e_33 = (IllegalArgumentException)_t_11;
        String _message_11 = e_33.getMessage();
        String _plus_11 = ("Invalid value: " + _message_11);
        this.error(_plus_11, type, SculptPackage.Literals.TYPE__EMPTY_VALUE);
      } else if (_t_11 instanceof UnsupportedOperationException) {
        final UnsupportedOperationException e_34 = (UnsupportedOperationException)_t_11;
        this.error("Unsupported parameter", type, SculptPackage.Literals.TYPE__EMPTY_VALUE);
      } else if (_t_11 instanceof Exception) {
        final Exception e_35 = (Exception)_t_11;
        this.error(e_35.getLocalizedMessage(), type, SculptPackage.Literals.TYPE__EMPTY_VALUE);
      } else {
        throw Exceptions.sneakyThrow(_t_11);
      }
    }
  }
  
  @Check
  public void checkAtomicType(final AtomicType type) {
    try {
      final Parser<?> parser = ParserProviderImpl.getParser(type.getBase());
      this.testParserParameters(parser, type);
    } catch (final Throwable _t) {
      if (_t instanceof IllegalArgumentException) {
        final IllegalArgumentException e = (IllegalArgumentException)_t;
        this.error("No such parser found", type, SculptPackage.Literals.ATOMIC_TYPE__BASE);
        return;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    if (((!Objects.equal(type.getMinLength(), null)) && ((type.getMinLength()).intValue() < 0))) {
      this.error("Value must be non-negative", type, SculptPackage.Literals.ATOMIC_TYPE__MIN_LENGTH);
    }
    if (((!Objects.equal(type.getMaxLength(), null)) && ((type.getMaxLength()).intValue() <= 0))) {
      this.error("Value must be positive", type, SculptPackage.Literals.ATOMIC_TYPE__MAX_LENGTH);
    }
    if (((!Objects.equal(type.getLength(), null)) && ((type.getLength()).intValue() <= 0))) {
      this.error("Value must be positive", type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
    }
    boolean _checkInterval = this.checkInterval(type.getMinLength(), type.getLength());
    boolean _not = (!_checkInterval);
    if (_not) {
      this.error("Conflicts with other bound", type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
    }
    boolean _checkInterval_1 = this.checkInterval(type.getLength(), type.getMaxLength());
    boolean _not_1 = (!_checkInterval_1);
    if (_not_1) {
      this.error("Conflicts with other bound", type, SculptPackage.Literals.ATOMIC_TYPE__LENGTH);
    }
    boolean _checkInterval_2 = this.checkInterval(type.getMinLength(), type.getMaxLength());
    boolean _not_2 = (!_checkInterval_2);
    if (_not_2) {
      this.error("Conflicts with other bound", type, SculptPackage.Literals.ATOMIC_TYPE__MAX_LENGTH);
    }
  }
  
  @Check
  public void checkToken(final Token tok) {
    if ((Objects.equal(tok.getTokenRegex(), null) || tok.getTokenRegex().isEmpty())) {
      return;
    }
    try {
      Pattern.compile(tok.getTokenRegex());
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        this.error(e.getLocalizedMessage(), tok, SculptPackage.Literals.TOKEN__TOKEN_REGEX);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkLoopVariables(final TLLoop loop) {
    if (((!Objects.equal(loop.getMode(), TLLoopMode.UNSPECIFIED)) && Objects.equal(loop.getContentExpression(), null))) {
      this.error("Expected content expression after region", loop, SculptPackage.Literals.TL_LOOP__MODE);
      return;
    }
    final int specNr = loop.getContentExpression().getList().size();
    final int varNr = loop.getVariables().size();
    if (((!Objects.equal(loop.getMode(), TLLoopMode.UNSPECIFIED)) && (specNr != varNr))) {
      int _size = loop.getContentExpression().getList().size();
      String _plus = ("Wrong number of arguments. Expected: " + Integer.valueOf(_size));
      String _plus_1 = (_plus + ", found: ");
      int _size_1 = loop.getVariables().size();
      String _plus_2 = (_plus_1 + Integer.valueOf(_size_1));
      this.error(_plus_2, loop, SculptPackage.Literals.TL_LOOP__VARIABLES);
    }
  }
  
  @Check
  public void checkColumSize(final TransformationProgram prog) {
    final List<TLOutput> outputs = EcoreUtil2.<TLOutput>getAllContentsOfType(prog, TLOutput.class);
    int _size = outputs.size();
    boolean _equals = (_size == 0);
    if (_equals) {
      return;
    }
    final int columns = outputs.get(0).getPrimitives().size();
    for (final TLOutput output : outputs) {
      int _size_1 = output.getPrimitives().size();
      boolean _notEquals = (columns != _size_1);
      if (_notEquals) {
        this.warning("Rows may have different number of cells", output, 
          SculptPackage.Literals.TL_OUTPUT__PRIMITIVES);
      }
    }
  }
  
  @Check
  public void checkCompoundType(final CompoundTypePrimitive t) {
    if ((Objects.equal(t.getText(), null) && Objects.equal(t.getType(), null))) {
      this.error("String or Type expected", t, null);
    }
  }
}
