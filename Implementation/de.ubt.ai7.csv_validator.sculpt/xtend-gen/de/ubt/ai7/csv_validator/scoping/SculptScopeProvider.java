/**
 * generated by Xtext
 */
package de.ubt.ai7.csv_validator.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import de.ubt.ai7.csv_validator.sculpt.AbstractToken;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypePrimitive;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypeSpecifier;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionComparison;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionToken;
import de.ubt.ai7.csv_validator.sculpt.ListType;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColToken;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionToken;
import de.ubt.ai7.csv_validator.sculpt.RegionToken;
import de.ubt.ai7.csv_validator.sculpt.Sculpt;
import de.ubt.ai7.csv_validator.sculpt.TLLoop;
import de.ubt.ai7.csv_validator.sculpt.TLOutputPrimitive;
import de.ubt.ai7.csv_validator.sculpt.TLSpecifier;
import de.ubt.ai7.csv_validator.sculpt.TLVariable;
import de.ubt.ai7.csv_validator.sculpt.Token;
import de.ubt.ai7.csv_validator.sculpt.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class SculptScopeProvider extends AbstractDeclarativeScopeProvider {
  protected IScope _symbolsDefinedBefore(final Sculpt s, final AbstractToken o) {
    IScope _xblockexpression = null;
    {
      List<AbstractToken> list = new ArrayList<AbstractToken>();
      EList<Type> _types = s.getTypes();
      EList<Token> _tokens = s.getTokens();
      Iterable<Token> _plus = Iterables.<Token>concat(_types, _tokens);
      EList<RegionToken> _regionTokens = s.getRegionTokens();
      Iterable<AbstractToken> _plus_1 = Iterables.<AbstractToken>concat(_plus, _regionTokens);
      for (final AbstractToken tok : _plus_1) {
        {
          boolean _equals = tok.equals(o);
          if (_equals) {
            return Scopes.scopeFor(list);
          }
          list.add(tok);
        }
      }
      _xblockexpression = Scopes.scopeFor(list);
    }
    return _xblockexpression;
  }
  
  protected IScope _symbolsDefinedBefore(final Sculpt s, final EObject o) {
    IScope _xblockexpression = null;
    {
      EList<Type> _types = s.getTypes();
      EList<Token> _tokens = s.getTokens();
      Iterable<Token> _plus = Iterables.<Token>concat(_types, _tokens);
      EList<RegionToken> _regionTokens = s.getRegionTokens();
      Iterable<AbstractToken> elements = Iterables.<AbstractToken>concat(_plus, _regionTokens);
      _xblockexpression = Scopes.scopeFor(elements);
    }
    return _xblockexpression;
  }
  
  protected IScope _symbolsDefinedBefore(final TLLoop l, final EObject o) {
    IScope _xblockexpression = null;
    {
      EList<TLVariable> _variables = l.getVariables();
      ArrayList<TLVariable> variables = new ArrayList<TLVariable>(_variables);
      _xblockexpression = Scopes.scopeFor(variables, 
        this.symbolsDefinedBefore(l.eContainer(), o.eContainer()));
    }
    return _xblockexpression;
  }
  
  protected IScope _symbolsDefinedBefore(final EObject cont, final EObject o) {
    return this.symbolsDefinedBefore(cont.eContainer(), o.eContainer());
  }
  
  /**
   * compute the scope for all objects with references
   */
  public IScope scope_CompoundTypePrimitive_type(final CompoundTypePrimitive context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_ListType_base(final ListType context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_NodeExpression_token(final NodeExpressionRowColToken context, final EReference r) {
    IScope _xifexpression = null;
    Token _token = context.getToken();
    boolean _notEquals = (!Objects.equal(_token, null));
    if (_notEquals) {
      _xifexpression = this.symbolsDefinedBefore(context.eContainer(), context);
    }
    return _xifexpression;
  }
  
  public IScope scope_NodeExpressionToken_token(final NodeExpressionToken context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_ContentExpressionToken_token(final ContentExpressionToken context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_ContentExpresionComparison_type(final ContentExpressionComparison context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_CompundTypeSpecifier_subtype(final CompoundTypeSpecifier context, final EReference r) {
    IScope _xifexpression = null;
    Type _subtype = context.getSubtype();
    boolean _notEquals = (!Objects.equal(_subtype, null));
    if (_notEquals) {
      _xifexpression = this.symbolsDefinedBefore(context.eContainer(), context);
    }
    return _xifexpression;
  }
  
  public IScope scope_TLOutputPrimitive_variable(final TLOutputPrimitive context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope scope_TLSpecifier_token(final TLSpecifier context, final EReference r) {
    return this.symbolsDefinedBefore(context.eContainer(), context);
  }
  
  public IScope symbolsDefinedBefore(final EObject l, final EObject o) {
    if (l instanceof TLLoop
         && o != null) {
      return _symbolsDefinedBefore((TLLoop)l, o);
    } else if (l instanceof Sculpt
         && o instanceof AbstractToken) {
      return _symbolsDefinedBefore((Sculpt)l, (AbstractToken)o);
    } else if (l instanceof Sculpt
         && o != null) {
      return _symbolsDefinedBefore((Sculpt)l, o);
    } else if (l != null
         && o != null) {
      return _symbolsDefinedBefore(l, o);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(l, o).toString());
    }
  }
}
