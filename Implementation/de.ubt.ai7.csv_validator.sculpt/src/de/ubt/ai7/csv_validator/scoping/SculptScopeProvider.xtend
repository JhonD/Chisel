/*
 * generated by Xtext
 */
package de.ubt.ai7.csv_validator.scoping

import de.ubt.ai7.csv_validator.sculpt.AbstractToken
import de.ubt.ai7.csv_validator.sculpt.CompoundTypePrimitive
import de.ubt.ai7.csv_validator.sculpt.CompoundTypeSpecifier
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionComparison
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionToken
import de.ubt.ai7.csv_validator.sculpt.ListType
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColToken
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionToken
import de.ubt.ai7.csv_validator.sculpt.Sculpt
import de.ubt.ai7.csv_validator.sculpt.TLLoop
import de.ubt.ai7.csv_validator.sculpt.TLOutputPrimitive
import de.ubt.ai7.csv_validator.sculpt.TLSpecifier
import de.ubt.ai7.csv_validator.sculpt.TLVariable
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 * 
 */
class SculptScopeProvider extends AbstractDeclarativeScopeProvider {

	// add all abstract tokens defined before the current one to the scope
	def dispatch IScope symbolsDefinedBefore(Sculpt s, AbstractToken o) {
		var List<AbstractToken> list = new ArrayList<AbstractToken>();
		for (tok : s.types + s.tokens + s.regionTokens) {
			if(tok.equals(o))
				return Scopes::scopeFor(list);
			list += tok;
		}
		Scopes::scopeFor(list);
	}

	// o is from a later section - make all abstract tokens available
	def dispatch IScope symbolsDefinedBefore(Sculpt s, EObject o) {
		var elements = s.types + s.tokens + s.regionTokens;
		Scopes::scopeFor(elements) // this ends recursion
	}
	
	// make variables defined in the loop header accessible in its body
	def dispatch IScope symbolsDefinedBefore(TLLoop l, EObject o) {
		var variables = new ArrayList<TLVariable>(l.variables);
		Scopes::scopeFor(
			variables,
			l.eContainer.symbolsDefinedBefore(o.eContainer) // outer scope
		)
	}
	
	// ascend the AST to get all outer scopes
	def dispatch IScope symbolsDefinedBefore(EObject cont, EObject o) {
		cont.eContainer.symbolsDefinedBefore(o.eContainer)
	}
	
	/*
	 * compute the scope for all objects with references
	 */


	def scope_CompoundTypePrimitive_type(CompoundTypePrimitive context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}
	
	def scope_ListType_base(ListType context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}

	def scope_NodeExpression_token(NodeExpressionRowColToken context, EReference r) {
		if(context.token != null)
			context.eContainer.symbolsDefinedBefore(context)
	}
	
	def scope_NodeExpressionToken_token(NodeExpressionToken context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}
	
	def scope_ContentExpressionToken_token(ContentExpressionToken context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}
	
	def scope_ContentExpresionComparison_type(ContentExpressionComparison context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}
	
	def scope_CompundTypeSpecifier_subtype(CompoundTypeSpecifier context, EReference r) {
		if(context.subtype != null)
			context.eContainer.symbolsDefinedBefore(context)
	}

	def scope_TLOutputPrimitive_variable(TLOutputPrimitive context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}

	def scope_TLSpecifier_token(TLSpecifier context, EReference r) {
		context.eContainer.symbolsDefinedBefore(context)
	}
	



}
