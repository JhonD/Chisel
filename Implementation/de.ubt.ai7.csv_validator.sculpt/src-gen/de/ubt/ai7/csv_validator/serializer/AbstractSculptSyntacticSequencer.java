/*
 * generated by Xtext
 */
package de.ubt.ai7.csv_validator.serializer;

import com.google.inject.Inject;
import de.ubt.ai7.csv_validator.services.SculptGrammarAccess;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AlternativeAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.GroupAlias;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.TokenAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynNavigable;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public abstract class AbstractSculptSyntacticSequencer extends AbstractSyntacticSequencer {

	protected SculptGrammarAccess grammarAccess;
	protected AbstractElementAlias match_AbstractToken_SemicolonKeyword_0_4_q;
	protected AbstractElementAlias match_Ce_Primitive_LeftParenthesisKeyword_0_0_a;
	protected AbstractElementAlias match_Ce_Primitive_LeftParenthesisKeyword_0_0_p;
	protected AbstractElementAlias match_Delimiters_SemicolonKeyword_0_0_3_q;
	protected AbstractElementAlias match_Delimiters_SemicolonKeyword_0_1_3_q;
	protected AbstractElementAlias match_Delimiters_SemicolonKeyword_1_3_q;
	protected AbstractElementAlias match_Ne_Primitive_LeftParenthesisKeyword_0_0_a;
	protected AbstractElementAlias match_Ne_Primitive_LeftParenthesisKeyword_0_0_p;
	protected AbstractElementAlias match_Pe_Atomic_ColonColonAsteriskKeyword_2_1_q;
	protected AbstractElementAlias match_Pe_Primitive_LeftParenthesisKeyword_0_0_a;
	protected AbstractElementAlias match_Pe_Primitive_LeftParenthesisKeyword_0_0_p;
	protected AbstractElementAlias match_Sculpt_REGIONSKeyword_4_0_q;
	protected AbstractElementAlias match_Sculpt_RULESKeyword_5_0_q;
	protected AbstractElementAlias match_Sculpt_TOKENSKeyword_3_0_q;
	protected AbstractElementAlias match_Sculpt_TYPESKeyword_2_0_q;
	protected AbstractElementAlias match_TLIf___ElseKeyword_7_0_LeftCurlyBracketKeyword_7_1_RightCurlyBracketKeyword_7_3__q;
	protected AbstractElementAlias match_Token_SemicolonKeyword_4_q;
	protected AbstractElementAlias match_Type_MaxInclusiveKeyword_0_4_7_0_1_or_MaximumKeyword_0_4_7_0_0;
	protected AbstractElementAlias match_Type_MinInclusiveKeyword_0_4_6_0_1_or_MinimumKeyword_0_4_6_0_0;
	protected AbstractElementAlias match_Type_PlusSignKeyword_1_3_1_q;
	protected AbstractElementAlias match_Type_SemicolonKeyword_0_5_q;
	protected AbstractElementAlias match_Type_SemicolonKeyword_1_6_q;
	protected AbstractElementAlias match_Type_SemicolonKeyword_2_4_q;
	protected AbstractElementAlias match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a__a;
	protected AbstractElementAlias match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a;
	protected AbstractElementAlias match_Type___ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a_GreaterThanSignKeyword_2_3_0_3__a;
	protected AbstractElementAlias match_Type___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a;
	protected AbstractElementAlias match_Type___UNBOUNDEDKeyword_2_3_0_2_2_2_1___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a_MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1__a;
	protected AbstractElementAlias match_Type_____GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___or___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1____a;
	protected AbstractElementAlias match_Type_____MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__q___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1_GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__q__p;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (SculptGrammarAccess) access;
		match_AbstractToken_SemicolonKeyword_0_4_q = new TokenAlias(false, true, grammarAccess.getAbstractTokenAccess().getSemicolonKeyword_0_4());
		match_Ce_Primitive_LeftParenthesisKeyword_0_0_a = new TokenAlias(true, true, grammarAccess.getCe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Ce_Primitive_LeftParenthesisKeyword_0_0_p = new TokenAlias(true, false, grammarAccess.getCe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Delimiters_SemicolonKeyword_0_0_3_q = new TokenAlias(false, true, grammarAccess.getDelimitersAccess().getSemicolonKeyword_0_0_3());
		match_Delimiters_SemicolonKeyword_0_1_3_q = new TokenAlias(false, true, grammarAccess.getDelimitersAccess().getSemicolonKeyword_0_1_3());
		match_Delimiters_SemicolonKeyword_1_3_q = new TokenAlias(false, true, grammarAccess.getDelimitersAccess().getSemicolonKeyword_1_3());
		match_Ne_Primitive_LeftParenthesisKeyword_0_0_a = new TokenAlias(true, true, grammarAccess.getNe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Ne_Primitive_LeftParenthesisKeyword_0_0_p = new TokenAlias(true, false, grammarAccess.getNe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Pe_Atomic_ColonColonAsteriskKeyword_2_1_q = new TokenAlias(false, true, grammarAccess.getPe_AtomicAccess().getColonColonAsteriskKeyword_2_1());
		match_Pe_Primitive_LeftParenthesisKeyword_0_0_a = new TokenAlias(true, true, grammarAccess.getPe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Pe_Primitive_LeftParenthesisKeyword_0_0_p = new TokenAlias(true, false, grammarAccess.getPe_PrimitiveAccess().getLeftParenthesisKeyword_0_0());
		match_Sculpt_REGIONSKeyword_4_0_q = new TokenAlias(false, true, grammarAccess.getSculptAccess().getREGIONSKeyword_4_0());
		match_Sculpt_RULESKeyword_5_0_q = new TokenAlias(false, true, grammarAccess.getSculptAccess().getRULESKeyword_5_0());
		match_Sculpt_TOKENSKeyword_3_0_q = new TokenAlias(false, true, grammarAccess.getSculptAccess().getTOKENSKeyword_3_0());
		match_Sculpt_TYPESKeyword_2_0_q = new TokenAlias(false, true, grammarAccess.getSculptAccess().getTYPESKeyword_2_0());
		match_TLIf___ElseKeyword_7_0_LeftCurlyBracketKeyword_7_1_RightCurlyBracketKeyword_7_3__q = new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getTLIfAccess().getElseKeyword_7_0()), new TokenAlias(false, false, grammarAccess.getTLIfAccess().getLeftCurlyBracketKeyword_7_1()), new TokenAlias(false, false, grammarAccess.getTLIfAccess().getRightCurlyBracketKeyword_7_3()));
		match_Token_SemicolonKeyword_4_q = new TokenAlias(false, true, grammarAccess.getTokenAccess().getSemicolonKeyword_4());
		match_Type_MaxInclusiveKeyword_0_4_7_0_1_or_MaximumKeyword_0_4_7_0_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxInclusiveKeyword_0_4_7_0_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaximumKeyword_0_4_7_0_0()));
		match_Type_MinInclusiveKeyword_0_4_6_0_1_or_MinimumKeyword_0_4_6_0_0 = new AlternativeAlias(false, false, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMinInclusiveKeyword_0_4_6_0_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getMinimumKeyword_0_4_6_0_0()));
		match_Type_PlusSignKeyword_1_3_1_q = new TokenAlias(false, true, grammarAccess.getTypeAccess().getPlusSignKeyword_1_3_1());
		match_Type_SemicolonKeyword_0_5_q = new TokenAlias(false, true, grammarAccess.getTypeAccess().getSemicolonKeyword_0_5());
		match_Type_SemicolonKeyword_1_6_q = new TokenAlias(false, true, grammarAccess.getTypeAccess().getSemicolonKeyword_1_6());
		match_Type_SemicolonKeyword_2_4_q = new TokenAlias(false, true, grammarAccess.getTypeAccess().getSemicolonKeyword_2_4());
		match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a__a = new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1()), new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1())));
		match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a = new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1()));
		match_Type___ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a_GreaterThanSignKeyword_2_3_0_3__a = new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1()), new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1())), new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()));
		match_Type___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a = new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1()));
		match_Type___UNBOUNDEDKeyword_2_3_0_2_2_2_1___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a_MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1__a = new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1()), new GroupAlias(true, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1())), new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()));
		match_Type_____GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___or___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1____a = new AlternativeAlias(true, true, new GroupAlias(false, false, new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1())), new GroupAlias(false, false, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1())));
		match_Type_____MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__q___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1_GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__q__p = new GroupAlias(true, false, new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1())), new GroupAlias(false, true, new TokenAlias(false, false, grammarAccess.getTypeAccess().getMaxElementsKeyword_2_3_0_2_2_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getEqualsSignKeyword_2_3_0_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getUNBOUNDEDKeyword_2_3_0_2_2_2_1()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getGreaterThanSignKeyword_2_3_0_3()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getListKeyword_2_3_0_0()), new TokenAlias(false, false, grammarAccess.getTypeAccess().getLessThanSignKeyword_2_3_0_1())));
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		return "";
	}
	
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			if (match_AbstractToken_SemicolonKeyword_0_4_q.equals(syntax))
				emit_AbstractToken_SemicolonKeyword_0_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Ce_Primitive_LeftParenthesisKeyword_0_0_a.equals(syntax))
				emit_Ce_Primitive_LeftParenthesisKeyword_0_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Ce_Primitive_LeftParenthesisKeyword_0_0_p.equals(syntax))
				emit_Ce_Primitive_LeftParenthesisKeyword_0_0_p(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Delimiters_SemicolonKeyword_0_0_3_q.equals(syntax))
				emit_Delimiters_SemicolonKeyword_0_0_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Delimiters_SemicolonKeyword_0_1_3_q.equals(syntax))
				emit_Delimiters_SemicolonKeyword_0_1_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Delimiters_SemicolonKeyword_1_3_q.equals(syntax))
				emit_Delimiters_SemicolonKeyword_1_3_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Ne_Primitive_LeftParenthesisKeyword_0_0_a.equals(syntax))
				emit_Ne_Primitive_LeftParenthesisKeyword_0_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Ne_Primitive_LeftParenthesisKeyword_0_0_p.equals(syntax))
				emit_Ne_Primitive_LeftParenthesisKeyword_0_0_p(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Pe_Atomic_ColonColonAsteriskKeyword_2_1_q.equals(syntax))
				emit_Pe_Atomic_ColonColonAsteriskKeyword_2_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Pe_Primitive_LeftParenthesisKeyword_0_0_a.equals(syntax))
				emit_Pe_Primitive_LeftParenthesisKeyword_0_0_a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Pe_Primitive_LeftParenthesisKeyword_0_0_p.equals(syntax))
				emit_Pe_Primitive_LeftParenthesisKeyword_0_0_p(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Sculpt_REGIONSKeyword_4_0_q.equals(syntax))
				emit_Sculpt_REGIONSKeyword_4_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Sculpt_RULESKeyword_5_0_q.equals(syntax))
				emit_Sculpt_RULESKeyword_5_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Sculpt_TOKENSKeyword_3_0_q.equals(syntax))
				emit_Sculpt_TOKENSKeyword_3_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Sculpt_TYPESKeyword_2_0_q.equals(syntax))
				emit_Sculpt_TYPESKeyword_2_0_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_TLIf___ElseKeyword_7_0_LeftCurlyBracketKeyword_7_1_RightCurlyBracketKeyword_7_3__q.equals(syntax))
				emit_TLIf___ElseKeyword_7_0_LeftCurlyBracketKeyword_7_1_RightCurlyBracketKeyword_7_3__q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Token_SemicolonKeyword_4_q.equals(syntax))
				emit_Token_SemicolonKeyword_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_MaxInclusiveKeyword_0_4_7_0_1_or_MaximumKeyword_0_4_7_0_0.equals(syntax))
				emit_Type_MaxInclusiveKeyword_0_4_7_0_1_or_MaximumKeyword_0_4_7_0_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_MinInclusiveKeyword_0_4_6_0_1_or_MinimumKeyword_0_4_6_0_0.equals(syntax))
				emit_Type_MinInclusiveKeyword_0_4_6_0_1_or_MinimumKeyword_0_4_6_0_0(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_PlusSignKeyword_1_3_1_q.equals(syntax))
				emit_Type_PlusSignKeyword_1_3_1_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_SemicolonKeyword_0_5_q.equals(syntax))
				emit_Type_SemicolonKeyword_0_5_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_SemicolonKeyword_1_6_q.equals(syntax))
				emit_Type_SemicolonKeyword_1_6_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_SemicolonKeyword_2_4_q.equals(syntax))
				emit_Type_SemicolonKeyword_2_4_q(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a__a.equals(syntax))
				emit_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a__a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a.equals(syntax))
				emit_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type___ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a_GreaterThanSignKeyword_2_3_0_3__a.equals(syntax))
				emit_Type___ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a_GreaterThanSignKeyword_2_3_0_3__a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a.equals(syntax))
				emit_Type___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type___UNBOUNDEDKeyword_2_3_0_2_2_2_1___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a_MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1__a.equals(syntax))
				emit_Type___UNBOUNDEDKeyword_2_3_0_2_2_2_1___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a_MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1__a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_____GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___or___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1____a.equals(syntax))
				emit_Type_____GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___or___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1____a(semanticObject, getLastNavigableState(), syntaxNodes);
			else if (match_Type_____MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__q___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1_GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__q__p.equals(syntax))
				emit_Type_____MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__q___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1_GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__q__p(semanticObject, getLastNavigableState(), syntaxNodes);
			else acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     tokenRegex=STRING (ambiguity) (rule end)
	 */
	protected void emit_AbstractToken_SemicolonKeyword_0_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('*
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) '(' type=[Type|ID]
	 *     (rule start) (ambiguity) './' path=Path_Expression
	 *     (rule start) (ambiguity) 'ANY' (rule start)
	 *     (rule start) (ambiguity) 'EMPTY' (rule start)
	 *     (rule start) (ambiguity) 'SOMETHING' (rule start)
	 *     (rule start) (ambiguity) string=STRING
	 *     (rule start) (ambiguity) token=[Token|ID]
	 *     (rule start) (ambiguity) type=[Type|ID]
	 *     (rule start) (ambiguity) value=STRING
	 *     (rule start) (ambiguity) {ContentExpressionList.first=}
	 *     (rule start) (ambiguity) {ContentExpressionOption.element=}
	 *     (rule start) (ambiguity) {ContentExpressionOr.left=}
	 *     (rule start) (ambiguity) {ContentExpressionPlus.element=}
	 *     (rule start) (ambiguity) {ContentExpressionStar.element=}
	 */
	protected void emit_Ce_Primitive_LeftParenthesisKeyword_0_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('+
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) {ContentExpressionList.first=}
	 *     (rule start) (ambiguity) {ContentExpressionOption.element=}
	 *     (rule start) (ambiguity) {ContentExpressionOr.left=}
	 *     (rule start) (ambiguity) {ContentExpressionPlus.element=}
	 *     (rule start) (ambiguity) {ContentExpressionStar.element=}
	 */
	protected void emit_Ce_Primitive_LeftParenthesisKeyword_0_0_p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     rowDelim=STRING (ambiguity) 'Col delim' '=' colDelim=STRING
	 *     rowDelim=STRING (ambiguity) 'List delim' '=' listDelim=STRING
	 *     rowDelim=STRING (ambiguity) 'Row delim' '=' rowDelim=STRING
	 *     rowDelim=STRING (ambiguity) (rule end)
	 */
	protected void emit_Delimiters_SemicolonKeyword_0_0_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     colDelim=STRING (ambiguity) 'Col delim' '=' colDelim=STRING
	 *     colDelim=STRING (ambiguity) 'List delim' '=' listDelim=STRING
	 *     colDelim=STRING (ambiguity) 'Row delim' '=' rowDelim=STRING
	 *     colDelim=STRING (ambiguity) (rule end)
	 */
	protected void emit_Delimiters_SemicolonKeyword_0_1_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     listDelim=STRING (ambiguity) 'Col delim' '=' colDelim=STRING
	 *     listDelim=STRING (ambiguity) 'List delim' '=' listDelim=STRING
	 *     listDelim=STRING (ambiguity) 'Row delim' '=' rowDelim=STRING
	 *     listDelim=STRING (ambiguity) (rule end)
	 */
	protected void emit_Delimiters_SemicolonKeyword_1_3_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('*
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) '(' row=INT
	 *     (rule start) (ambiguity) '/' path=Path_Expression
	 *     (rule start) (ambiguity) 'True' (rule start)
	 *     (rule start) (ambiguity) 'not' region=Ne_Path
	 *     (rule start) (ambiguity) mode=RowCol
	 *     (rule start) (ambiguity) path=Path_Expression
	 *     (rule start) (ambiguity) token=[AbstractToken|ID]
	 *     (rule start) (ambiguity) type=[Type|ID]
	 *     (rule start) (ambiguity) value=STRING
	 *     (rule start) (ambiguity) {NodeExpressionAnd.left=}
	 *     (rule start) (ambiguity) {NodeExpressionOr.left=}
	 *     (rule start) (ambiguity) {NodeExpressionPath.region=}
	 */
	protected void emit_Ne_Primitive_LeftParenthesisKeyword_0_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('+
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) '/' path=Path_Expression
	 *     (rule start) (ambiguity) 'not' region=Ne_Path
	 *     (rule start) (ambiguity) path=Path_Expression
	 *     (rule start) (ambiguity) {NodeExpressionAnd.left=}
	 *     (rule start) (ambiguity) {NodeExpressionOr.left=}
	 *     (rule start) (ambiguity) {NodeExpressionPath.region=}
	 */
	protected void emit_Ne_Primitive_LeftParenthesisKeyword_0_0_p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '::*'?
	 *
	 * This ambiguous syntax occurs at:
	 *     axes='down' (ambiguity) '[' predicate=NodeExpression
	 *     axes='down' (ambiguity) (rule end)
	 *     axes='left' (ambiguity) '[' predicate=NodeExpression
	 *     axes='left' (ambiguity) (rule end)
	 *     axes='right' (ambiguity) '[' predicate=NodeExpression
	 *     axes='right' (ambiguity) (rule end)
	 *     axes='self' (ambiguity) '[' predicate=NodeExpression
	 *     axes='self' (ambiguity) (rule end)
	 *     axes='up' (ambiguity) '[' predicate=NodeExpression
	 *     axes='up' (ambiguity) (rule end)
	 */
	protected void emit_Pe_Atomic_ColonColonAsteriskKeyword_2_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('*
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) axes='down'
	 *     (rule start) (ambiguity) axes='left'
	 *     (rule start) (ambiguity) axes='right'
	 *     (rule start) (ambiguity) axes='self'
	 *     (rule start) (ambiguity) axes='up'
	 *     (rule start) (ambiguity) {PathExpressionList.first=}
	 *     (rule start) (ambiguity) {PathExpressionOption.element=}
	 *     (rule start) (ambiguity) {PathExpressionOr.left=}
	 *     (rule start) (ambiguity) {PathExpressionPlus.element=}
	 *     (rule start) (ambiguity) {PathExpressionStar.element=}
	 */
	protected void emit_Pe_Primitive_LeftParenthesisKeyword_0_0_a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '('+
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) {PathExpressionList.first=}
	 *     (rule start) (ambiguity) {PathExpressionOption.element=}
	 *     (rule start) (ambiguity) {PathExpressionOr.left=}
	 *     (rule start) (ambiguity) {PathExpressionPlus.element=}
	 *     (rule start) (ambiguity) {PathExpressionStar.element=}
	 */
	protected void emit_Pe_Primitive_LeftParenthesisKeyword_0_0_p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'REGIONS'?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'TYPES'? 'TOKENS'? (ambiguity) 'RULES' constraints+=Constraint
	 *     (rule start) 'TYPES'? 'TOKENS'? (ambiguity) 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     (rule start) 'TYPES'? 'TOKENS'? (ambiguity) 'RULES'? (rule start)
	 *     delimiter=Delimiters 'TYPES'? 'TOKENS'? (ambiguity) 'RULES' constraints+=Constraint
	 *     delimiter=Delimiters 'TYPES'? 'TOKENS'? (ambiguity) 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     delimiter=Delimiters 'TYPES'? 'TOKENS'? (ambiguity) 'RULES'? (rule end)
	 *     tokens+=Token (ambiguity) 'RULES' constraints+=Constraint
	 *     tokens+=Token (ambiguity) 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     tokens+=Token (ambiguity) 'RULES'? (rule end)
	 *     types+=Type 'TOKENS'? (ambiguity) 'RULES' constraints+=Constraint
	 *     types+=Type 'TOKENS'? (ambiguity) 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     types+=Type 'TOKENS'? (ambiguity) 'RULES'? (rule end)
	 */
	protected void emit_Sculpt_REGIONSKeyword_4_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'RULES'?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'TYPES'? 'TOKENS'? 'REGIONS'? (ambiguity) 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     (rule start) 'TYPES'? 'TOKENS'? 'REGIONS'? (ambiguity) (rule start)
	 *     delimiter=Delimiters 'TYPES'? 'TOKENS'? 'REGIONS'? (ambiguity) 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     delimiter=Delimiters 'TYPES'? 'TOKENS'? 'REGIONS'? (ambiguity) (rule end)
	 *     regionTokens+=RegionToken (ambiguity) 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     regionTokens+=RegionToken (ambiguity) (rule end)
	 *     tokens+=Token 'REGIONS'? (ambiguity) 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     tokens+=Token 'REGIONS'? (ambiguity) (rule end)
	 *     types+=Type 'TOKENS'? 'REGIONS'? (ambiguity) 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     types+=Type 'TOKENS'? 'REGIONS'? (ambiguity) (rule end)
	 */
	protected void emit_Sculpt_RULESKeyword_5_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'TOKENS'?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) 'TYPES'? (ambiguity) 'REGIONS' regionTokens+=RegionToken
	 *     (rule start) 'TYPES'? (ambiguity) 'REGIONS'? 'RULES' constraints+=Constraint
	 *     (rule start) 'TYPES'? (ambiguity) 'REGIONS'? 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     (rule start) 'TYPES'? (ambiguity) 'REGIONS'? 'RULES'? (rule start)
	 *     delimiter=Delimiters 'TYPES'? (ambiguity) 'REGIONS' regionTokens+=RegionToken
	 *     delimiter=Delimiters 'TYPES'? (ambiguity) 'REGIONS'? 'RULES' constraints+=Constraint
	 *     delimiter=Delimiters 'TYPES'? (ambiguity) 'REGIONS'? 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     delimiter=Delimiters 'TYPES'? (ambiguity) 'REGIONS'? 'RULES'? (rule end)
	 *     types+=Type (ambiguity) 'REGIONS' regionTokens+=RegionToken
	 *     types+=Type (ambiguity) 'REGIONS'? 'RULES' constraints+=Constraint
	 *     types+=Type (ambiguity) 'REGIONS'? 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     types+=Type (ambiguity) 'REGIONS'? 'RULES'? (rule end)
	 */
	protected void emit_Sculpt_TOKENSKeyword_3_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'TYPES'?
	 *
	 * This ambiguous syntax occurs at:
	 *     (rule start) (ambiguity) 'TOKENS' tokens+=Token
	 *     (rule start) (ambiguity) 'TOKENS'? 'REGIONS' regionTokens+=RegionToken
	 *     (rule start) (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES' constraints+=Constraint
	 *     (rule start) (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     (rule start) (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES'? (rule start)
	 *     delimiter=Delimiters (ambiguity) 'TOKENS' tokens+=Token
	 *     delimiter=Delimiters (ambiguity) 'TOKENS'? 'REGIONS' regionTokens+=RegionToken
	 *     delimiter=Delimiters (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES' constraints+=Constraint
	 *     delimiter=Delimiters (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES'? 'TRANSFORMATION PROGRAM' transformationProgram=TransformationProgram
	 *     delimiter=Delimiters (ambiguity) 'TOKENS'? 'REGIONS'? 'RULES'? (rule end)
	 */
	protected void emit_Sculpt_TYPESKeyword_2_0_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('else' '{' '}')?
	 *
	 * This ambiguous syntax occurs at:
	 *     condition=TLBoolExpr ')' '{' '}' (ambiguity) (rule end)
	 *     ifBlock+=TLStatement '}' (ambiguity) (rule end)
	 */
	protected void emit_TLIf___ElseKeyword_7_0_LeftCurlyBracketKeyword_7_1_RightCurlyBracketKeyword_7_3__q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     tokenRegex=STRING (ambiguity) (rule end)
	 */
	protected void emit_Token_SemicolonKeyword_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'maximum' | 'maxInclusive'
	 *
	 * This ambiguous syntax occurs at:
	 *     base=STRING (ambiguity) '=' maximum=STRING
	 *     decimalChar=STRING (ambiguity) '=' maximum=STRING
	 *     defaultValue=STRING (ambiguity) '=' maximum=STRING
	 *     emptyValue=STRING (ambiguity) '=' maximum=STRING
	 *     format=STRING (ambiguity) '=' maximum=STRING
	 *     groupChar=STRING (ambiguity) '=' maximum=STRING
	 *     length=INT (ambiguity) '=' maximum=STRING
	 *     maxExclusive=STRING (ambiguity) '=' maximum=STRING
	 *     maxLength=INT (ambiguity) '=' maximum=STRING
	 *     maximum=STRING (ambiguity) '=' maximum=STRING
	 *     minExclusive=STRING (ambiguity) '=' maximum=STRING
	 *     minLength=INT (ambiguity) '=' maximum=STRING
	 *     minimum=STRING (ambiguity) '=' maximum=STRING
	 */
	protected void emit_Type_MaxInclusiveKeyword_0_4_7_0_1_or_MaximumKeyword_0_4_7_0_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     'minimum' | 'minInclusive'
	 *
	 * This ambiguous syntax occurs at:
	 *     base=STRING (ambiguity) '=' minimum=STRING
	 *     decimalChar=STRING (ambiguity) '=' minimum=STRING
	 *     defaultValue=STRING (ambiguity) '=' minimum=STRING
	 *     emptyValue=STRING (ambiguity) '=' minimum=STRING
	 *     format=STRING (ambiguity) '=' minimum=STRING
	 *     groupChar=STRING (ambiguity) '=' minimum=STRING
	 *     length=INT (ambiguity) '=' minimum=STRING
	 *     maxExclusive=STRING (ambiguity) '=' minimum=STRING
	 *     maxLength=INT (ambiguity) '=' minimum=STRING
	 *     maximum=STRING (ambiguity) '=' minimum=STRING
	 *     minExclusive=STRING (ambiguity) '=' minimum=STRING
	 *     minLength=INT (ambiguity) '=' minimum=STRING
	 *     minimum=STRING (ambiguity) '=' minimum=STRING
	 */
	protected void emit_Type_MinInclusiveKeyword_0_4_6_0_1_or_MinimumKeyword_0_4_6_0_0(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     '+'?
	 *
	 * This ambiguous syntax occurs at:
	 *     primitives+=CompoundTypePrimitive (ambiguity) primitives+=CompoundTypePrimitive
	 */
	protected void emit_Type_PlusSignKeyword_1_3_1_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     base=STRING (ambiguity) (rule end)
	 *     decimalChar=STRING (ambiguity) (rule end)
	 *     defaultValue=STRING (ambiguity) (rule end)
	 *     emptyValue=STRING (ambiguity) (rule end)
	 *     format=STRING (ambiguity) (rule end)
	 *     groupChar=STRING (ambiguity) (rule end)
	 *     length=INT (ambiguity) (rule end)
	 *     maxExclusive=STRING (ambiguity) (rule end)
	 *     maxLength=INT (ambiguity) (rule end)
	 *     maximum=STRING (ambiguity) (rule end)
	 *     minExclusive=STRING (ambiguity) (rule end)
	 *     minLength=INT (ambiguity) (rule end)
	 *     minimum=STRING (ambiguity) (rule end)
	 */
	protected void emit_Type_SemicolonKeyword_0_5_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     defaultValue=STRING (ambiguity) (rule end)
	 *     emptyValue=STRING (ambiguity) (rule end)
	 *     primitives+=CompoundTypePrimitive (ambiguity) (rule end)
	 */
	protected void emit_Type_SemicolonKeyword_1_6_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ';'?
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] ('maxElements' '=' 'UNBOUNDED')* '>' ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     defaultValue=STRING ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     emptyValue=STRING ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     maxElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     minElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     name=ID ':' ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 *     separator=STRING ('maxElements' '=' 'UNBOUNDED')* '>' ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')* (ambiguity) (rule end)
	 */
	protected void emit_Type_SemicolonKeyword_2_4_q(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('>' 'list' '<' ('maxElements' '=' 'UNBOUNDED')*)*
	 *
	 * This ambiguous syntax occurs at:
	 *     defaultValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'base' '=' base=[Type|ID]
	 *     defaultValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'minElements' '=' minElements=INT
	 *     defaultValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'separator' '=' separator=STRING
	 *     emptyValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'base' '=' base=[Type|ID]
	 *     emptyValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'minElements' '=' minElements=INT
	 *     emptyValue=STRING 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'separator' '=' separator=STRING
	 *     name=ID ':' 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'base' '=' base=[Type|ID]
	 *     name=ID ':' 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'minElements' '=' minElements=INT
	 *     name=ID ':' 'list' '<' ('maxElements' '=' 'UNBOUNDED')* (ambiguity) 'separator' '=' separator=STRING
	 */
	protected void emit_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a__a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('>' 'list' '<')*
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] (ambiguity) 'maxElements' '=' ('UNBOUNDED' (ambiguity) 'maxElements' '=')* maxElements=INT
	 *     defaultValue=STRING 'list' '<' (ambiguity) (('maxElements' '=' 'UNBOUNDED')? ('maxElements' '=' 'UNBOUNDED' '>' 'list' '<')?)+ 'maxElements' '=' maxElements=INT
	 *     emptyValue=STRING 'list' '<' (ambiguity) (('maxElements' '=' 'UNBOUNDED')? ('maxElements' '=' 'UNBOUNDED' '>' 'list' '<')?)+ 'maxElements' '=' maxElements=INT
	 *     maxElements=INT (ambiguity) 'maxElements' '=' ('UNBOUNDED' (ambiguity) 'maxElements' '=')* maxElements=INT
	 *     minElements=INT (ambiguity) 'maxElements' '=' ('UNBOUNDED' (ambiguity) 'maxElements' '=')* maxElements=INT
	 *     name=ID ':' 'list' '<' (ambiguity) (('maxElements' '=' 'UNBOUNDED')? ('maxElements' '=' 'UNBOUNDED' '>' 'list' '<')?)+ 'maxElements' '=' maxElements=INT
	 *     separator=STRING (ambiguity) 'maxElements' '=' ('UNBOUNDED' (ambiguity) 'maxElements' '=')* maxElements=INT
	 */
	protected void emit_Type___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('list' '<' ('maxElements' '=' 'UNBOUNDED')* '>')*
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) ';'? (rule end)
	 *     base=[Type|ID] ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'default' '=' defaultValue=STRING
	 *     base=[Type|ID] ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'empty' '=' emptyValue=STRING
	 *     defaultValue=STRING (ambiguity) ';'? (rule end)
	 *     defaultValue=STRING (ambiguity) 'default' '=' defaultValue=STRING
	 *     defaultValue=STRING (ambiguity) 'empty' '=' emptyValue=STRING
	 *     emptyValue=STRING (ambiguity) ';'? (rule end)
	 *     emptyValue=STRING (ambiguity) 'default' '=' defaultValue=STRING
	 *     emptyValue=STRING (ambiguity) 'empty' '=' emptyValue=STRING
	 *     maxElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) ';'? (rule end)
	 *     maxElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'default' '=' defaultValue=STRING
	 *     maxElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'empty' '=' emptyValue=STRING
	 *     minElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) ';'? (rule end)
	 *     minElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'default' '=' defaultValue=STRING
	 *     minElements=INT ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'empty' '=' emptyValue=STRING
	 *     name=ID ':' (ambiguity) ';'? (rule end)
	 *     name=ID ':' (ambiguity) 'default' '=' defaultValue=STRING
	 *     name=ID ':' (ambiguity) 'empty' '=' emptyValue=STRING
	 *     separator=STRING ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) ';'? (rule end)
	 *     separator=STRING ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'default' '=' defaultValue=STRING
	 *     separator=STRING ('maxElements' '=' 'UNBOUNDED')* '>' (ambiguity) 'empty' '=' emptyValue=STRING
	 */
	protected void emit_Type___ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a_GreaterThanSignKeyword_2_3_0_3__a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('maxElements' '=' 'UNBOUNDED')*
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] (ambiguity) '>' ('list' '<' (ambiguity) '>')* ';'? (rule end)
	 *     base=[Type|ID] (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'default' '=' defaultValue=STRING
	 *     base=[Type|ID] (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'empty' '=' emptyValue=STRING
	 *     defaultValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'base' '=' base=[Type|ID]
	 *     defaultValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'minElements' '=' minElements=INT
	 *     defaultValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'separator' '=' separator=STRING
	 *     emptyValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'base' '=' base=[Type|ID]
	 *     emptyValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'minElements' '=' minElements=INT
	 *     emptyValue=STRING 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'separator' '=' separator=STRING
	 *     maxElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* ';'? (rule end)
	 *     maxElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'default' '=' defaultValue=STRING
	 *     maxElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'empty' '=' emptyValue=STRING
	 *     minElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* ';'? (rule end)
	 *     minElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'default' '=' defaultValue=STRING
	 *     minElements=INT (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'empty' '=' emptyValue=STRING
	 *     name=ID ':' 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'base' '=' base=[Type|ID]
	 *     name=ID ':' 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'minElements' '=' minElements=INT
	 *     name=ID ':' 'list' '<' (ambiguity) ('>' 'list' '<' (ambiguity))* 'separator' '=' separator=STRING
	 *     separator=STRING (ambiguity) '>' ('list' '<' (ambiguity) '>')* ';'? (rule end)
	 *     separator=STRING (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'default' '=' defaultValue=STRING
	 *     separator=STRING (ambiguity) '>' ('list' '<' (ambiguity) '>')* 'empty' '=' emptyValue=STRING
	 */
	protected void emit_Type___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     ('UNBOUNDED' ('>' 'list' '<')* 'maxElements' '=')*
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] ('>' 'list' '<')* 'maxElements' '=' (ambiguity) maxElements=INT
	 *     maxElements=INT ('>' 'list' '<')* 'maxElements' '=' (ambiguity) maxElements=INT
	 *     minElements=INT ('>' 'list' '<')* 'maxElements' '=' (ambiguity) maxElements=INT
	 *     separator=STRING ('>' 'list' '<')* 'maxElements' '=' (ambiguity) maxElements=INT
	 */
	protected void emit_Type___UNBOUNDEDKeyword_2_3_0_2_2_2_1___GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__a_MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1__a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (('>' 'list' '<') | ('maxElements' '=' 'UNBOUNDED'))*
	 *
	 * This ambiguous syntax occurs at:
	 *     base=[Type|ID] (ambiguity) 'base' '=' base=[Type|ID]
	 *     base=[Type|ID] (ambiguity) 'minElements' '=' minElements=INT
	 *     base=[Type|ID] (ambiguity) 'separator' '=' separator=STRING
	 *     maxElements=INT (ambiguity) 'base' '=' base=[Type|ID]
	 *     maxElements=INT (ambiguity) 'minElements' '=' minElements=INT
	 *     maxElements=INT (ambiguity) 'separator' '=' separator=STRING
	 *     minElements=INT (ambiguity) 'base' '=' base=[Type|ID]
	 *     minElements=INT (ambiguity) 'minElements' '=' minElements=INT
	 *     minElements=INT (ambiguity) 'separator' '=' separator=STRING
	 *     separator=STRING (ambiguity) 'base' '=' base=[Type|ID]
	 *     separator=STRING (ambiguity) 'minElements' '=' minElements=INT
	 *     separator=STRING (ambiguity) 'separator' '=' separator=STRING
	 */
	protected void emit_Type_____GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1___or___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1____a(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
	/**
	 * Ambiguous syntax:
	 *     (
	  *         ('maxElements' '=' 'UNBOUNDED')? 
	  *         (
	  *             'maxElements' 
	  *             '=' 
	  *             'UNBOUNDED' 
	  *             '>' 
	  *             'list' 
	  *             '<'
	  *         )?
	  *     )+
	 *
	 * This ambiguous syntax occurs at:
	 *     defaultValue=STRING 'list' '<' ('>' 'list' '<')* (ambiguity) 'maxElements' '=' maxElements=INT
	 *     emptyValue=STRING 'list' '<' ('>' 'list' '<')* (ambiguity) 'maxElements' '=' maxElements=INT
	 *     name=ID ':' 'list' '<' ('>' 'list' '<')* (ambiguity) 'maxElements' '=' maxElements=INT
	 */
	protected void emit_Type_____MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1__q___MaxElementsKeyword_2_3_0_2_2_0_EqualsSignKeyword_2_3_0_2_2_1_UNBOUNDEDKeyword_2_3_0_2_2_2_1_GreaterThanSignKeyword_2_3_0_3_ListKeyword_2_3_0_0_LessThanSignKeyword_2_3_0_1__q__p(EObject semanticObject, ISynNavigable transition, List<INode> nodes) {
		acceptNodes(transition, nodes);
	}
	
}
