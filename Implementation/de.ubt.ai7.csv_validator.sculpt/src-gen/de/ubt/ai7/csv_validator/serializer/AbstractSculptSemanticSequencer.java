/*
 * generated by Xtext
 */
package de.ubt.ai7.csv_validator.serializer;

import com.google.inject.Inject;
import de.ubt.ai7.csv_validator.sculpt.AtomicType;
import de.ubt.ai7.csv_validator.sculpt.CompoundType;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypePrimitive;
import de.ubt.ai7.csv_validator.sculpt.CompoundTypeSpecifier;
import de.ubt.ai7.csv_validator.sculpt.ContentConstraint;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionANY;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionComparison;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionComparisonR2L;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionEMPTY;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionList;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionOption;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionOr;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionPlus;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionSOMETHING;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionStar;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionString;
import de.ubt.ai7.csv_validator.sculpt.ContentExpressionToken;
import de.ubt.ai7.csv_validator.sculpt.Delimiters;
import de.ubt.ai7.csv_validator.sculpt.ForeignKeyConstraint;
import de.ubt.ai7.csv_validator.sculpt.ListType;
import de.ubt.ai7.csv_validator.sculpt.ListTypeSpecifier;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionAnd;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionComparison;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionComparisonR2L;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionComplete;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionCoordinate;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionNot;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionOr;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionPath;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColCoordinate;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColLast;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColString;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionRowColToken;
import de.ubt.ai7.csv_validator.sculpt.NodeExpressionToken;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionList;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionOption;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionOr;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionPlus;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionPredicate;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionStar;
import de.ubt.ai7.csv_validator.sculpt.PathExpressionStep;
import de.ubt.ai7.csv_validator.sculpt.PrimaryKeyConstraint;
import de.ubt.ai7.csv_validator.sculpt.RegionToken;
import de.ubt.ai7.csv_validator.sculpt.Sculpt;
import de.ubt.ai7.csv_validator.sculpt.SculptPackage;
import de.ubt.ai7.csv_validator.sculpt.TLBoolExprEmpty;
import de.ubt.ai7.csv_validator.sculpt.TLBoolExprNot;
import de.ubt.ai7.csv_validator.sculpt.TLContentExpressionList;
import de.ubt.ai7.csv_validator.sculpt.TLIf;
import de.ubt.ai7.csv_validator.sculpt.TLLoop;
import de.ubt.ai7.csv_validator.sculpt.TLOutput;
import de.ubt.ai7.csv_validator.sculpt.TLOutputConstant;
import de.ubt.ai7.csv_validator.sculpt.TLOutputVariable;
import de.ubt.ai7.csv_validator.sculpt.TLVariable;
import de.ubt.ai7.csv_validator.sculpt.Token;
import de.ubt.ai7.csv_validator.sculpt.TransformationProgram;
import de.ubt.ai7.csv_validator.sculpt.TupleSelector;
import de.ubt.ai7.csv_validator.services.SculptGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractSculptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SculptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SculptPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SculptPackage.ATOMIC_TYPE:
				sequence_Type(context, (AtomicType) semanticObject); 
				return; 
			case SculptPackage.COMPOUND_TYPE:
				sequence_Type(context, (CompoundType) semanticObject); 
				return; 
			case SculptPackage.COMPOUND_TYPE_PRIMITIVE:
				sequence_CompoundTypePrimitive(context, (CompoundTypePrimitive) semanticObject); 
				return; 
			case SculptPackage.COMPOUND_TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (CompoundTypeSpecifier) semanticObject); 
				return; 
			case SculptPackage.CONTENT_CONSTRAINT:
				sequence_ContentConstraint(context, (ContentConstraint) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_ANY:
				sequence_Ce_Atomic_TL_Ce_Atomic(context, (ContentExpressionANY) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_COMPARISON:
				sequence_Ce_Comparison(context, (ContentExpressionComparison) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_COMPARISON_R2L:
				sequence_Ce_Comparison(context, (ContentExpressionComparisonR2L) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_EMPTY:
				sequence_Ce_Atomic_TL_Ce_Atomic(context, (ContentExpressionEMPTY) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_LIST:
				sequence_Ce_List(context, (ContentExpressionList) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_OPTION:
				if (rule == grammarAccess.getContentExpressionRule()
						|| rule == grammarAccess.getCe_OrRule()
						|| action == grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getCe_ListRule()
						|| action == grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0()
						|| rule == grammarAccess.getCe_RecursiveRule()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getCe_PrimitiveRule()) {
					sequence_Ce_Recursive(context, (ContentExpressionOption) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTL_Ce_RecursiveRule()) {
					sequence_TL_Ce_Recursive(context, (ContentExpressionOption) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.CONTENT_EXPRESSION_OR:
				sequence_Ce_Or(context, (ContentExpressionOr) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_PLUS:
				if (rule == grammarAccess.getContentExpressionRule()
						|| rule == grammarAccess.getCe_OrRule()
						|| action == grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getCe_ListRule()
						|| action == grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0()
						|| rule == grammarAccess.getCe_RecursiveRule()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getCe_PrimitiveRule()) {
					sequence_Ce_Recursive(context, (ContentExpressionPlus) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTL_Ce_RecursiveRule()) {
					sequence_TL_Ce_Recursive(context, (ContentExpressionPlus) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.CONTENT_EXPRESSION_SOMETHING:
				sequence_Ce_Atomic_TL_Ce_Atomic(context, (ContentExpressionSOMETHING) semanticObject); 
				return; 
			case SculptPackage.CONTENT_EXPRESSION_STAR:
				if (rule == grammarAccess.getContentExpressionRule()
						|| rule == grammarAccess.getCe_OrRule()
						|| action == grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getCe_ListRule()
						|| action == grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0()
						|| rule == grammarAccess.getCe_RecursiveRule()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getCe_PrimitiveRule()) {
					sequence_Ce_Recursive(context, (ContentExpressionStar) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTL_Ce_RecursiveRule()) {
					sequence_TL_Ce_Recursive(context, (ContentExpressionStar) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.CONTENT_EXPRESSION_STRING:
				if (rule == grammarAccess.getContentExpressionRule()
						|| rule == grammarAccess.getCe_OrRule()
						|| action == grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getCe_ListRule()
						|| action == grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0()
						|| rule == grammarAccess.getCe_RecursiveRule()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getCe_PrimitiveRule()
						|| rule == grammarAccess.getCe_AtomicRule()) {
					sequence_Ce_Atomic(context, (ContentExpressionString) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTL_Ce_RecursiveRule()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getTL_Ce_AtomicRule()) {
					sequence_TL_Ce_Atomic(context, (ContentExpressionString) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.CONTENT_EXPRESSION_TOKEN:
				if (rule == grammarAccess.getContentExpressionRule()
						|| rule == grammarAccess.getCe_OrRule()
						|| action == grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0()
						|| rule == grammarAccess.getCe_ListRule()
						|| action == grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0()
						|| rule == grammarAccess.getCe_RecursiveRule()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getCe_PrimitiveRule()
						|| rule == grammarAccess.getCe_AtomicRule()) {
					sequence_Ce_Atomic(context, (ContentExpressionToken) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTL_Ce_RecursiveRule()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionStarElementAction_1_0_0()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0()
						|| action == grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0()
						|| rule == grammarAccess.getTL_Ce_AtomicRule()) {
					sequence_TL_Ce_Atomic(context, (ContentExpressionToken) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.DELIMITERS:
				sequence_Delimiters(context, (Delimiters) semanticObject); 
				return; 
			case SculptPackage.FOREIGN_KEY_CONSTRAINT:
				sequence_ForeignKeyConstraint(context, (ForeignKeyConstraint) semanticObject); 
				return; 
			case SculptPackage.LIST_TYPE:
				sequence_Type(context, (ListType) semanticObject); 
				return; 
			case SculptPackage.LIST_TYPE_SPECIFIER:
				sequence_TypeSpecifier(context, (ListTypeSpecifier) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_AND:
				sequence_Ne_And(context, (NodeExpressionAnd) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_COMPARISON:
				sequence_Ne_Comparison(context, (NodeExpressionComparison) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_COMPARISON_R2L:
				sequence_Ne_Comparison(context, (NodeExpressionComparisonR2L) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_COMPLETE:
				sequence_Ne_Atomic(context, (NodeExpressionComplete) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_COORDINATE:
				sequence_Ne_Atomic_Node_Test(context, (NodeExpressionCoordinate) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_NOT:
				sequence_Ne_Not(context, (NodeExpressionNot) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_OR:
				sequence_Ne_Or(context, (NodeExpressionOr) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_PATH:
				sequence_Ne_Path(context, (NodeExpressionPath) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_ROW_COL_COORDINATE:
				sequence_Ne_Atomic(context, (NodeExpressionRowColCoordinate) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_ROW_COL_LAST:
				sequence_Ne_Atomic(context, (NodeExpressionRowColLast) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_ROW_COL_STRING:
				sequence_Ne_Atomic(context, (NodeExpressionRowColString) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_ROW_COL_TOKEN:
				sequence_Ne_Atomic(context, (NodeExpressionRowColToken) semanticObject); 
				return; 
			case SculptPackage.NODE_EXPRESSION_TOKEN:
				sequence_Ne_Atomic_Node_Test(context, (NodeExpressionToken) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_LIST:
				sequence_Path_Expression(context, (PathExpressionList) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_OPTION:
				sequence_Pe_Regex(context, (PathExpressionOption) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_OR:
				sequence_Pe_Or(context, (PathExpressionOr) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_PLUS:
				sequence_Pe_Regex(context, (PathExpressionPlus) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_PREDICATE:
				sequence_Ne_Path(context, (PathExpressionPredicate) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_STAR:
				sequence_Pe_Regex(context, (PathExpressionStar) semanticObject); 
				return; 
			case SculptPackage.PATH_EXPRESSION_STEP:
				sequence_Pe_Atomic(context, (PathExpressionStep) semanticObject); 
				return; 
			case SculptPackage.PRIMARY_KEY_CONSTRAINT:
				sequence_PrimaryKeyConstraint(context, (PrimaryKeyConstraint) semanticObject); 
				return; 
			case SculptPackage.REGION_TOKEN:
				if (rule == grammarAccess.getAbstractTokenRule()) {
					sequence_AbstractToken(context, (RegionToken) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRegionTokenRule()) {
					sequence_RegionToken(context, (RegionToken) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.SCULPT:
				sequence_Sculpt(context, (Sculpt) semanticObject); 
				return; 
			case SculptPackage.TL_BOOL_EXPR_EMPTY:
				sequence_TLBoolExprEmpty(context, (TLBoolExprEmpty) semanticObject); 
				return; 
			case SculptPackage.TL_BOOL_EXPR_NOT:
				sequence_TLBoolExprNot(context, (TLBoolExprNot) semanticObject); 
				return; 
			case SculptPackage.TL_CONTENT_EXPRESSION_LIST:
				sequence_TL_Ce_List(context, (TLContentExpressionList) semanticObject); 
				return; 
			case SculptPackage.TL_IF:
				sequence_TLIf(context, (TLIf) semanticObject); 
				return; 
			case SculptPackage.TL_LOOP:
				sequence_TLLoop(context, (TLLoop) semanticObject); 
				return; 
			case SculptPackage.TL_OUTPUT:
				sequence_TLOutput(context, (TLOutput) semanticObject); 
				return; 
			case SculptPackage.TL_OUTPUT_CONSTANT:
				sequence_TLOutputPrimitive(context, (TLOutputConstant) semanticObject); 
				return; 
			case SculptPackage.TL_OUTPUT_VARIABLE:
				sequence_TLOutputPrimitive(context, (TLOutputVariable) semanticObject); 
				return; 
			case SculptPackage.TL_VARIABLE:
				sequence_TLVariable(context, (TLVariable) semanticObject); 
				return; 
			case SculptPackage.TOKEN:
				if (rule == grammarAccess.getAbstractTokenRule()) {
					sequence_AbstractToken(context, (Token) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTokenRule()) {
					sequence_Token(context, (Token) semanticObject); 
					return; 
				}
				else break;
			case SculptPackage.TRANSFORMATION_PROGRAM:
				sequence_TransformationProgram(context, (TransformationProgram) semanticObject); 
				return; 
			case SculptPackage.TUPLE_SELECTOR:
				sequence_TupleSelector(context, (TupleSelector) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractToken returns RegionToken
	 *
	 * Constraint:
	 *     (name=ID region=NodeExpression)
	 */
	protected void sequence_AbstractToken(ISerializationContext context, RegionToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.REGION_TOKEN__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.REGION_TOKEN__REGION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbstractTokenAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAbstractTokenAccess().getRegionNodeExpressionParserRuleCall_1_3_0(), semanticObject.getRegion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractToken returns Token
	 *
	 * Constraint:
	 *     (name=ID tokenRegex=STRING)
	 */
	protected void sequence_AbstractToken(ISerializationContext context, Token semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.TOKEN__TOKEN_REGEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.TOKEN__TOKEN_REGEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbstractTokenAccess().getNameIDTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAbstractTokenAccess().getTokenRegexSTRINGTerminalRuleCall_0_3_0(), semanticObject.getTokenRegex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionString
	 *     Ce_Or returns ContentExpressionString
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionString
	 *     Ce_List returns ContentExpressionString
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionString
	 *     Ce_Recursive returns ContentExpressionString
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionString
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionString
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionString
	 *     Ce_Primitive returns ContentExpressionString
	 *     Ce_Atomic returns ContentExpressionString
	 *
	 * Constraint:
	 *     string=STRING
	 */
	protected void sequence_Ce_Atomic(ISerializationContext context, ContentExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STRING__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STRING__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_AtomicAccess().getStringSTRINGTerminalRuleCall_1_1_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionToken
	 *     Ce_Or returns ContentExpressionToken
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionToken
	 *     Ce_List returns ContentExpressionToken
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionToken
	 *     Ce_Recursive returns ContentExpressionToken
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionToken
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionToken
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionToken
	 *     Ce_Primitive returns ContentExpressionToken
	 *     Ce_Atomic returns ContentExpressionToken
	 *
	 * Constraint:
	 *     token=[Token|ID]
	 */
	protected void sequence_Ce_Atomic(ISerializationContext context, ContentExpressionToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_TOKEN__TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_TOKEN__TOKEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_AtomicAccess().getTokenTokenIDTerminalRuleCall_0_1_0_1(), semanticObject.getToken());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionANY
	 *     Ce_Or returns ContentExpressionANY
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionANY
	 *     Ce_List returns ContentExpressionANY
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionANY
	 *     Ce_Recursive returns ContentExpressionANY
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionANY
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionANY
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionANY
	 *     Ce_Primitive returns ContentExpressionANY
	 *     Ce_Atomic returns ContentExpressionANY
	 *     TL_Ce_Recursive returns ContentExpressionANY
	 *     TL_Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionANY
	 *     TL_Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionANY
	 *     TL_Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionANY
	 *     TL_Ce_Atomic returns ContentExpressionANY
	 *
	 * Constraint:
	 *     {ContentExpressionANY}
	 */
	protected void sequence_Ce_Atomic_TL_Ce_Atomic(ISerializationContext context, ContentExpressionANY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionEMPTY
	 *     Ce_Or returns ContentExpressionEMPTY
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionEMPTY
	 *     Ce_List returns ContentExpressionEMPTY
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionEMPTY
	 *     Ce_Recursive returns ContentExpressionEMPTY
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionEMPTY
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionEMPTY
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionEMPTY
	 *     Ce_Primitive returns ContentExpressionEMPTY
	 *     Ce_Atomic returns ContentExpressionEMPTY
	 *     TL_Ce_Recursive returns ContentExpressionEMPTY
	 *     TL_Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionEMPTY
	 *     TL_Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionEMPTY
	 *     TL_Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionEMPTY
	 *     TL_Ce_Atomic returns ContentExpressionEMPTY
	 *
	 * Constraint:
	 *     {ContentExpressionEMPTY}
	 */
	protected void sequence_Ce_Atomic_TL_Ce_Atomic(ISerializationContext context, ContentExpressionEMPTY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionSOMETHING
	 *     Ce_Or returns ContentExpressionSOMETHING
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionSOMETHING
	 *     Ce_List returns ContentExpressionSOMETHING
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionSOMETHING
	 *     Ce_Recursive returns ContentExpressionSOMETHING
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionSOMETHING
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionSOMETHING
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionSOMETHING
	 *     Ce_Primitive returns ContentExpressionSOMETHING
	 *     Ce_Atomic returns ContentExpressionSOMETHING
	 *     TL_Ce_Recursive returns ContentExpressionSOMETHING
	 *     TL_Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionSOMETHING
	 *     TL_Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionSOMETHING
	 *     TL_Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionSOMETHING
	 *     TL_Ce_Atomic returns ContentExpressionSOMETHING
	 *
	 * Constraint:
	 *     {ContentExpressionSOMETHING}
	 */
	protected void sequence_Ce_Atomic_TL_Ce_Atomic(ISerializationContext context, ContentExpressionSOMETHING semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionComparison
	 *     Ce_Or returns ContentExpressionComparison
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionComparison
	 *     Ce_List returns ContentExpressionComparison
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionComparison
	 *     Ce_Recursive returns ContentExpressionComparison
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionComparison
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionComparison
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionComparison
	 *     Ce_Primitive returns ContentExpressionComparison
	 *     Ce_Comparison returns ContentExpressionComparison
	 *
	 * Constraint:
	 *     (
	 *         (type=[Type|ID] typeSpecifier+=TypeSpecifier* comp=Comparator value=STRING) | 
	 *         (type=[Type|ID] typeSpecifier+=TypeSpecifier* comp=Comparator path=Path_Expression)
	 *     )
	 */
	protected void sequence_Ce_Comparison(ISerializationContext context, ContentExpressionComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionComparisonR2L
	 *     Ce_Or returns ContentExpressionComparisonR2L
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionComparisonR2L
	 *     Ce_List returns ContentExpressionComparisonR2L
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionComparisonR2L
	 *     Ce_Recursive returns ContentExpressionComparisonR2L
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionComparisonR2L
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionComparisonR2L
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionComparisonR2L
	 *     Ce_Primitive returns ContentExpressionComparisonR2L
	 *     Ce_Comparison returns ContentExpressionComparisonR2L
	 *
	 * Constraint:
	 *     ((path=Path_Expression | value=STRING) comp=Comparator type=[Type|ID] typeSpecifier+=TypeSpecifier*)
	 */
	protected void sequence_Ce_Comparison(ISerializationContext context, ContentExpressionComparisonR2L semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionList
	 *     Ce_Or returns ContentExpressionList
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionList
	 *     Ce_List returns ContentExpressionList
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionList
	 *     Ce_Recursive returns ContentExpressionList
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionList
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionList
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionList
	 *     Ce_Primitive returns ContentExpressionList
	 *
	 * Constraint:
	 *     (first=Ce_List_ContentExpressionList_1_0 rest=Ce_Recursive)
	 */
	protected void sequence_Ce_List(ISerializationContext context, ContentExpressionList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_LIST__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_LIST__FIRST));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_LIST__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_LIST__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_ListAccess().getContentExpressionListFirstAction_1_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getCe_ListAccess().getRestCe_RecursiveParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionOr
	 *     Ce_Or returns ContentExpressionOr
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionOr
	 *     Ce_List returns ContentExpressionOr
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionOr
	 *     Ce_Recursive returns ContentExpressionOr
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionOr
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionOr
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionOr
	 *     Ce_Primitive returns ContentExpressionOr
	 *
	 * Constraint:
	 *     (left=Ce_Or_ContentExpressionOr_1_0 right=Ce_List)
	 */
	protected void sequence_Ce_Or(ISerializationContext context, ContentExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_OrAccess().getContentExpressionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCe_OrAccess().getRightCe_ListParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionOption
	 *     Ce_Or returns ContentExpressionOption
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionOption
	 *     Ce_List returns ContentExpressionOption
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionOption
	 *     Ce_Recursive returns ContentExpressionOption
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionOption
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionOption
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionOption
	 *     Ce_Primitive returns ContentExpressionOption
	 *
	 * Constraint:
	 *     element=Ce_Recursive_ContentExpressionOption_1_2_0
	 */
	protected void sequence_Ce_Recursive(ISerializationContext context, ContentExpressionOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OPTION__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OPTION__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionPlus
	 *     Ce_Or returns ContentExpressionPlus
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionPlus
	 *     Ce_List returns ContentExpressionPlus
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionPlus
	 *     Ce_Recursive returns ContentExpressionPlus
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionPlus
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionPlus
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionPlus
	 *     Ce_Primitive returns ContentExpressionPlus
	 *
	 * Constraint:
	 *     element=Ce_Recursive_ContentExpressionPlus_1_1_0
	 */
	protected void sequence_Ce_Recursive(ISerializationContext context, ContentExpressionPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_PLUS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_PLUS__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContentExpression returns ContentExpressionStar
	 *     Ce_Or returns ContentExpressionStar
	 *     Ce_Or.ContentExpressionOr_1_0 returns ContentExpressionStar
	 *     Ce_List returns ContentExpressionStar
	 *     Ce_List.ContentExpressionList_1_0 returns ContentExpressionStar
	 *     Ce_Recursive returns ContentExpressionStar
	 *     Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionStar
	 *     Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionStar
	 *     Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionStar
	 *     Ce_Primitive returns ContentExpressionStar
	 *
	 * Constraint:
	 *     element=Ce_Recursive_ContentExpressionStar_1_0_0
	 */
	protected void sequence_Ce_Recursive(ISerializationContext context, ContentExpressionStar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STAR__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STAR__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCe_RecursiveAccess().getContentExpressionStarElementAction_1_0_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompoundTypePrimitive returns CompoundTypePrimitive
	 *
	 * Constraint:
	 *     (text=STRING | type=[Type|ID])
	 */
	protected void sequence_CompoundTypePrimitive(ISerializationContext context, CompoundTypePrimitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns ContentConstraint
	 *     ContentConstraint returns ContentConstraint
	 *
	 * Constraint:
	 *     (region=NodeExpression validationMode=ValidationMode contentExpression=ContentExpression)
	 */
	protected void sequence_ContentConstraint(ISerializationContext context, ContentConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__REGION));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__VALIDATION_MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__VALIDATION_MODE));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__CONTENT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_CONSTRAINT__CONTENT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContentConstraintAccess().getRegionNodeExpressionParserRuleCall_0_0(), semanticObject.getRegion());
		feeder.accept(grammarAccess.getContentConstraintAccess().getValidationModeValidationModeEnumRuleCall_1_0(), semanticObject.getValidationMode());
		feeder.accept(grammarAccess.getContentConstraintAccess().getContentExpressionContentExpressionParserRuleCall_2_0(), semanticObject.getContentExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Delimiters returns Delimiters
	 *
	 * Constraint:
	 *     (rowDelim=STRING | colDelim=STRING | listDelim=STRING)+
	 */
	protected void sequence_Delimiters(ISerializationContext context, Delimiters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns ForeignKeyConstraint
	 *     ForeignKeyConstraint returns ForeignKeyConstraint
	 *
	 * Constraint:
	 *     (tupleSelector=TupleSelector referencedRelation=[PrimaryKeyConstraint|ID])
	 */
	protected void sequence_ForeignKeyConstraint(ISerializationContext context, ForeignKeyConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.RELATION_CONSTRAINT__TUPLE_SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.RELATION_CONSTRAINT__TUPLE_SELECTOR));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.FOREIGN_KEY_CONSTRAINT__REFERENCED_RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.FOREIGN_KEY_CONSTRAINT__REFERENCED_RELATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForeignKeyConstraintAccess().getTupleSelectorTupleSelectorParserRuleCall_2_0(), semanticObject.getTupleSelector());
		feeder.accept(grammarAccess.getForeignKeyConstraintAccess().getReferencedRelationPrimaryKeyConstraintIDTerminalRuleCall_4_0_1(), semanticObject.getReferencedRelation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionAnd
	 *     Ne_Or returns NodeExpressionAnd
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionAnd
	 *     Ne_And returns NodeExpressionAnd
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionAnd
	 *     Ne_Not returns NodeExpressionAnd
	 *     Ne_Path returns NodeExpressionAnd
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionAnd
	 *     Ne_Primitive returns NodeExpressionAnd
	 *
	 * Constraint:
	 *     (left=Ne_And_NodeExpressionAnd_1_0 right=Ne_Not)
	 */
	protected void sequence_Ne_And(ISerializationContext context, NodeExpressionAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_AndAccess().getNodeExpressionAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNe_AndAccess().getRightNe_NotParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionComplete
	 *     Ne_Or returns NodeExpressionComplete
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionComplete
	 *     Ne_And returns NodeExpressionComplete
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionComplete
	 *     Ne_Not returns NodeExpressionComplete
	 *     Ne_Path returns NodeExpressionComplete
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionComplete
	 *     Ne_Primitive returns NodeExpressionComplete
	 *     Ne_Atomic returns NodeExpressionComplete
	 *
	 * Constraint:
	 *     {NodeExpressionComplete}
	 */
	protected void sequence_Ne_Atomic(ISerializationContext context, NodeExpressionComplete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionRowColCoordinate
	 *     Ne_Or returns NodeExpressionRowColCoordinate
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionRowColCoordinate
	 *     Ne_And returns NodeExpressionRowColCoordinate
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionRowColCoordinate
	 *     Ne_Not returns NodeExpressionRowColCoordinate
	 *     Ne_Path returns NodeExpressionRowColCoordinate
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionRowColCoordinate
	 *     Ne_Primitive returns NodeExpressionRowColCoordinate
	 *     Ne_Atomic returns NodeExpressionRowColCoordinate
	 *
	 * Constraint:
	 *     ((mode=RowCol row=INT column=INT) | (mode=RowCol index=INT))
	 */
	protected void sequence_Ne_Atomic(ISerializationContext context, NodeExpressionRowColCoordinate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionRowColLast
	 *     Ne_Or returns NodeExpressionRowColLast
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionRowColLast
	 *     Ne_And returns NodeExpressionRowColLast
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionRowColLast
	 *     Ne_Not returns NodeExpressionRowColLast
	 *     Ne_Path returns NodeExpressionRowColLast
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionRowColLast
	 *     Ne_Primitive returns NodeExpressionRowColLast
	 *     Ne_Atomic returns NodeExpressionRowColLast
	 *
	 * Constraint:
	 *     mode=RowCol
	 */
	protected void sequence_Ne_Atomic(ISerializationContext context, NodeExpressionRowColLast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_AtomicAccess().getModeRowColEnumRuleCall_5_1_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionRowColString
	 *     Ne_Or returns NodeExpressionRowColString
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionRowColString
	 *     Ne_And returns NodeExpressionRowColString
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionRowColString
	 *     Ne_Not returns NodeExpressionRowColString
	 *     Ne_Path returns NodeExpressionRowColString
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionRowColString
	 *     Ne_Primitive returns NodeExpressionRowColString
	 *     Ne_Atomic returns NodeExpressionRowColString
	 *
	 * Constraint:
	 *     (mode=RowCol string=STRING)
	 */
	protected void sequence_Ne_Atomic(ISerializationContext context, NodeExpressionRowColString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL_STRING__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL_STRING__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_AtomicAccess().getModeRowColEnumRuleCall_4_1_0(), semanticObject.getMode());
		feeder.accept(grammarAccess.getNe_AtomicAccess().getStringSTRINGTerminalRuleCall_4_3_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionRowColToken
	 *     Ne_Or returns NodeExpressionRowColToken
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionRowColToken
	 *     Ne_And returns NodeExpressionRowColToken
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionRowColToken
	 *     Ne_Not returns NodeExpressionRowColToken
	 *     Ne_Path returns NodeExpressionRowColToken
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionRowColToken
	 *     Ne_Primitive returns NodeExpressionRowColToken
	 *     Ne_Atomic returns NodeExpressionRowColToken
	 *
	 * Constraint:
	 *     (mode=RowCol token=[Token|ID])
	 */
	protected void sequence_Ne_Atomic(ISerializationContext context, NodeExpressionRowColToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL__MODE));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL_TOKEN__TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_ROW_COL_TOKEN__TOKEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_AtomicAccess().getModeRowColEnumRuleCall_3_1_0(), semanticObject.getMode());
		feeder.accept(grammarAccess.getNe_AtomicAccess().getTokenTokenIDTerminalRuleCall_3_3_0_1(), semanticObject.getToken());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionCoordinate
	 *     Ne_Or returns NodeExpressionCoordinate
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionCoordinate
	 *     Ne_And returns NodeExpressionCoordinate
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionCoordinate
	 *     Ne_Not returns NodeExpressionCoordinate
	 *     Ne_Path returns NodeExpressionCoordinate
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionCoordinate
	 *     Ne_Primitive returns NodeExpressionCoordinate
	 *     Ne_Atomic returns NodeExpressionCoordinate
	 *     Ne_Atomic_Node_Test returns NodeExpressionCoordinate
	 *
	 * Constraint:
	 *     (row=INT column=INT)
	 */
	protected void sequence_Ne_Atomic_Node_Test(ISerializationContext context, NodeExpressionCoordinate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_COORDINATE__ROW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_COORDINATE__ROW));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_COORDINATE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_COORDINATE__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_Atomic_Node_TestAccess().getRowINTTerminalRuleCall_0_2_0(), semanticObject.getRow());
		feeder.accept(grammarAccess.getNe_Atomic_Node_TestAccess().getColumnINTTerminalRuleCall_0_4_0(), semanticObject.getColumn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionToken
	 *     Ne_Or returns NodeExpressionToken
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionToken
	 *     Ne_And returns NodeExpressionToken
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionToken
	 *     Ne_Not returns NodeExpressionToken
	 *     Ne_Path returns NodeExpressionToken
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionToken
	 *     Ne_Primitive returns NodeExpressionToken
	 *     Ne_Atomic returns NodeExpressionToken
	 *     Ne_Atomic_Node_Test returns NodeExpressionToken
	 *
	 * Constraint:
	 *     token=[AbstractToken|ID]
	 */
	protected void sequence_Ne_Atomic_Node_Test(ISerializationContext context, NodeExpressionToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_TOKEN__TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_TOKEN__TOKEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_Atomic_Node_TestAccess().getTokenAbstractTokenIDTerminalRuleCall_1_1_0_1(), semanticObject.getToken());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionComparison
	 *     Ne_Or returns NodeExpressionComparison
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionComparison
	 *     Ne_And returns NodeExpressionComparison
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionComparison
	 *     Ne_Not returns NodeExpressionComparison
	 *     Ne_Path returns NodeExpressionComparison
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionComparison
	 *     Ne_Primitive returns NodeExpressionComparison
	 *     Ne_Comparison returns NodeExpressionComparison
	 *
	 * Constraint:
	 *     (type=[Type|ID] typeSpecifier+=TypeSpecifier* comp=Comparator value=STRING)
	 */
	protected void sequence_Ne_Comparison(ISerializationContext context, NodeExpressionComparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionComparisonR2L
	 *     Ne_Or returns NodeExpressionComparisonR2L
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionComparisonR2L
	 *     Ne_And returns NodeExpressionComparisonR2L
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionComparisonR2L
	 *     Ne_Not returns NodeExpressionComparisonR2L
	 *     Ne_Path returns NodeExpressionComparisonR2L
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionComparisonR2L
	 *     Ne_Primitive returns NodeExpressionComparisonR2L
	 *     Ne_Comparison returns NodeExpressionComparisonR2L
	 *
	 * Constraint:
	 *     (value=STRING comp=Comparator type=[Type|ID] typeSpecifier+=TypeSpecifier*)
	 */
	protected void sequence_Ne_Comparison(ISerializationContext context, NodeExpressionComparisonR2L semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionNot
	 *     Ne_Or returns NodeExpressionNot
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionNot
	 *     Ne_And returns NodeExpressionNot
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionNot
	 *     Ne_Not returns NodeExpressionNot
	 *     Ne_Path returns NodeExpressionNot
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionNot
	 *     Ne_Primitive returns NodeExpressionNot
	 *
	 * Constraint:
	 *     region=Ne_Path
	 */
	protected void sequence_Ne_Not(ISerializationContext context, NodeExpressionNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_NOT__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_NOT__REGION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_NotAccess().getRegionNe_PathParserRuleCall_0_2_0(), semanticObject.getRegion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionOr
	 *     Ne_Or returns NodeExpressionOr
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionOr
	 *     Ne_And returns NodeExpressionOr
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionOr
	 *     Ne_Not returns NodeExpressionOr
	 *     Ne_Path returns NodeExpressionOr
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionOr
	 *     Ne_Primitive returns NodeExpressionOr
	 *
	 * Constraint:
	 *     (left=Ne_Or_NodeExpressionOr_1_0 right=Ne_And)
	 */
	protected void sequence_Ne_Or(ISerializationContext context, NodeExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.NODE_EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_OrAccess().getNodeExpressionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getNe_OrAccess().getRightNe_AndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns NodeExpressionPath
	 *     Ne_Or returns NodeExpressionPath
	 *     Ne_Or.NodeExpressionOr_1_0 returns NodeExpressionPath
	 *     Ne_And returns NodeExpressionPath
	 *     Ne_And.NodeExpressionAnd_1_0 returns NodeExpressionPath
	 *     Ne_Not returns NodeExpressionPath
	 *     Ne_Path returns NodeExpressionPath
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns NodeExpressionPath
	 *     Ne_Primitive returns NodeExpressionPath
	 *
	 * Constraint:
	 *     ((region=Ne_Path_NodeExpressionPath_0_1_0 path=Path_Expression) | path=Path_Expression)
	 */
	protected void sequence_Ne_Path(ISerializationContext context, NodeExpressionPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeExpression returns PathExpressionPredicate
	 *     Ne_Or returns PathExpressionPredicate
	 *     Ne_Or.NodeExpressionOr_1_0 returns PathExpressionPredicate
	 *     Ne_And returns PathExpressionPredicate
	 *     Ne_And.NodeExpressionAnd_1_0 returns PathExpressionPredicate
	 *     Ne_Not returns PathExpressionPredicate
	 *     Ne_Path returns PathExpressionPredicate
	 *     Ne_Path.NodeExpressionPath_0_1_0 returns PathExpressionPredicate
	 *     Ne_Primitive returns PathExpressionPredicate
	 *
	 * Constraint:
	 *     path=Path_Expression
	 */
	protected void sequence_Ne_Path(ISerializationContext context, PathExpressionPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_PREDICATE__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_PREDICATE__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNe_PathAccess().getPathPath_ExpressionParserRuleCall_2_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionList
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionList
	 *     Pe_Regex returns PathExpressionList
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionList
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionList
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionList
	 *     Pe_Primitive returns PathExpressionList
	 *     Pe_Or returns PathExpressionList
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionList
	 *
	 * Constraint:
	 *     (first=Path_Expression_PathExpressionList_1_0 rest+=Pe_Regex+)
	 */
	protected void sequence_Path_Expression(ISerializationContext context, PathExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionStep
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionStep
	 *     Pe_Regex returns PathExpressionStep
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionStep
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionStep
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionStep
	 *     Pe_Primitive returns PathExpressionStep
	 *     Pe_Or returns PathExpressionStep
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionStep
	 *     Pe_Atomic returns PathExpressionStep
	 *
	 * Constraint:
	 *     ((axes='right' | axes='down' | axes='left' | axes='up' | axes='self') node_test=Ne_Atomic_Node_Test? predicate=NodeExpression?)
	 */
	protected void sequence_Pe_Atomic(ISerializationContext context, PathExpressionStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionOr
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionOr
	 *     Pe_Regex returns PathExpressionOr
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionOr
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionOr
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionOr
	 *     Pe_Primitive returns PathExpressionOr
	 *     Pe_Or returns PathExpressionOr
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionOr
	 *
	 * Constraint:
	 *     (left=Pe_Or_PathExpressionOr_1_0 right=Path_Expression)
	 */
	protected void sequence_Pe_Or(ISerializationContext context, PathExpressionOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPe_OrAccess().getPathExpressionOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPe_OrAccess().getRightPath_ExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionOption
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionOption
	 *     Pe_Regex returns PathExpressionOption
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionOption
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionOption
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionOption
	 *     Pe_Primitive returns PathExpressionOption
	 *     Pe_Or returns PathExpressionOption
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionOption
	 *
	 * Constraint:
	 *     element=Pe_Regex_PathExpressionOption_1_2_0
	 */
	protected void sequence_Pe_Regex(ISerializationContext context, PathExpressionOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OPTION__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_OPTION__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPe_RegexAccess().getPathExpressionOptionElementAction_1_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionPlus
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionPlus
	 *     Pe_Regex returns PathExpressionPlus
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionPlus
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionPlus
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionPlus
	 *     Pe_Primitive returns PathExpressionPlus
	 *     Pe_Or returns PathExpressionPlus
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionPlus
	 *
	 * Constraint:
	 *     element=Pe_Regex_PathExpressionPlus_1_1_0
	 */
	protected void sequence_Pe_Regex(ISerializationContext context, PathExpressionPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_PLUS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_PLUS__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPe_RegexAccess().getPathExpressionPlusElementAction_1_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Path_Expression returns PathExpressionStar
	 *     Path_Expression.PathExpressionList_1_0 returns PathExpressionStar
	 *     Pe_Regex returns PathExpressionStar
	 *     Pe_Regex.PathExpressionStar_1_0_0 returns PathExpressionStar
	 *     Pe_Regex.PathExpressionPlus_1_1_0 returns PathExpressionStar
	 *     Pe_Regex.PathExpressionOption_1_2_0 returns PathExpressionStar
	 *     Pe_Primitive returns PathExpressionStar
	 *     Pe_Or returns PathExpressionStar
	 *     Pe_Or.PathExpressionOr_1_0 returns PathExpressionStar
	 *
	 * Constraint:
	 *     element=Pe_Regex_PathExpressionStar_1_0_0
	 */
	protected void sequence_Pe_Regex(ISerializationContext context, PathExpressionStar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_STAR__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PATH_EXPRESSION_STAR__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPe_RegexAccess().getPathExpressionStarElementAction_1_0_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns PrimaryKeyConstraint
	 *     PrimaryKeyConstraint returns PrimaryKeyConstraint
	 *
	 * Constraint:
	 *     (name=ID tupleSelector=TupleSelector)
	 */
	protected void sequence_PrimaryKeyConstraint(ISerializationContext context, PrimaryKeyConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.PRIMARY_KEY_CONSTRAINT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.PRIMARY_KEY_CONSTRAINT__NAME));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.RELATION_CONSTRAINT__TUPLE_SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.RELATION_CONSTRAINT__TUPLE_SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryKeyConstraintAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPrimaryKeyConstraintAccess().getTupleSelectorTupleSelectorParserRuleCall_4_0(), semanticObject.getTupleSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegionToken returns RegionToken
	 *
	 * Constraint:
	 *     (name=ID region=NodeExpression)
	 */
	protected void sequence_RegionToken(ISerializationContext context, RegionToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.REGION_TOKEN__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.REGION_TOKEN__REGION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegionTokenAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRegionTokenAccess().getRegionNodeExpressionParserRuleCall_3_0(), semanticObject.getRegion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sculpt returns Sculpt
	 *
	 * Constraint:
	 *     (
	 *         delimiter=Delimiters? 
	 *         types+=Type* 
	 *         tokens+=Token* 
	 *         regionTokens+=RegionToken* 
	 *         constraints+=Constraint* 
	 *         transformationProgram=TransformationProgram?
	 *     )
	 */
	protected void sequence_Sculpt(ISerializationContext context, Sculpt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TLBoolExpr returns TLBoolExprEmpty
	 *     TLBoolExprEmpty returns TLBoolExprEmpty
	 *
	 * Constraint:
	 *     region=NodeExpression
	 */
	protected void sequence_TLBoolExprEmpty(ISerializationContext context, TLBoolExprEmpty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.TL_BOOL_EXPR_EMPTY__REGION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.TL_BOOL_EXPR_EMPTY__REGION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTLBoolExprEmptyAccess().getRegionNodeExpressionParserRuleCall_0_0(), semanticObject.getRegion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TLBoolExpr returns TLBoolExprNot
	 *     TLBoolExprNot returns TLBoolExprNot
	 *
	 * Constraint:
	 *     expression=TLBoolExpr
	 */
	protected void sequence_TLBoolExprNot(ISerializationContext context, TLBoolExprNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.TL_BOOL_EXPR_NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.TL_BOOL_EXPR_NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTLBoolExprNotAccess().getExpressionTLBoolExprParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TLStatement returns TLIf
	 *     TLIf returns TLIf
	 *
	 * Constraint:
	 *     (condition=TLBoolExpr ifBlock+=TLStatement* elseBlock+=TLStatement*)
	 */
	protected void sequence_TLIf(ISerializationContext context, TLIf semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TLLoop returns TLLoop
	 *     TLStatement returns TLLoop
	 *
	 * Constraint:
	 *     (variables+=TLVariable variables+=TLVariable* region=NodeExpression (mode=TLLoopMode contentExpression=TL_Ce_List)? statements+=TLStatement*)
	 */
	protected void sequence_TLLoop(ISerializationContext context, TLLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TLOutputPrimitive returns TLOutputConstant
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_TLOutputPrimitive(ISerializationContext context, TLOutputConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.TL_OUTPUT_CONSTANT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.TL_OUTPUT_CONSTANT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTLOutputPrimitiveAccess().getTextSTRINGTerminalRuleCall_0_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TLOutputPrimitive returns TLOutputVariable
	 *
	 * Constraint:
	 *     (variable=[TLVariable|ID] typeSpecifier+=TypeSpecifier*)
	 */
	protected void sequence_TLOutputPrimitive(ISerializationContext context, TLOutputVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TLOutput returns TLOutput
	 *     TLStatement returns TLOutput
	 *
	 * Constraint:
	 *     (primitives+=TLOutputPrimitive primitives+=TLOutputPrimitive*)
	 */
	protected void sequence_TLOutput(ISerializationContext context, TLOutput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TLVariable returns TLVariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TLVariable(ISerializationContext context, TLVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTLVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_Recursive returns ContentExpressionString
	 *     TL_Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionString
	 *     TL_Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionString
	 *     TL_Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionString
	 *     TL_Ce_Atomic returns ContentExpressionString
	 *
	 * Constraint:
	 *     string=STRING
	 */
	protected void sequence_TL_Ce_Atomic(ISerializationContext context, ContentExpressionString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STRING__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STRING__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTL_Ce_AtomicAccess().getStringSTRINGTerminalRuleCall_1_1_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_Recursive returns ContentExpressionToken
	 *     TL_Ce_Recursive.ContentExpressionStar_1_0_0 returns ContentExpressionToken
	 *     TL_Ce_Recursive.ContentExpressionPlus_1_1_0 returns ContentExpressionToken
	 *     TL_Ce_Recursive.ContentExpressionOption_1_2_0 returns ContentExpressionToken
	 *     TL_Ce_Atomic returns ContentExpressionToken
	 *
	 * Constraint:
	 *     token=[Token|ID]
	 */
	protected void sequence_TL_Ce_Atomic(ISerializationContext context, ContentExpressionToken semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_TOKEN__TOKEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_TOKEN__TOKEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTL_Ce_AtomicAccess().getTokenTokenIDTerminalRuleCall_0_1_0_1(), semanticObject.getToken());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_List returns TLContentExpressionList
	 *
	 * Constraint:
	 *     (list+=TL_Ce_Recursive list+=Ce_Recursive*)
	 */
	protected void sequence_TL_Ce_List(ISerializationContext context, TLContentExpressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_Recursive returns ContentExpressionOption
	 *
	 * Constraint:
	 *     element=TL_Ce_Recursive_ContentExpressionOption_1_2_0
	 */
	protected void sequence_TL_Ce_Recursive(ISerializationContext context, ContentExpressionOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OPTION__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_OPTION__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionOptionElementAction_1_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_Recursive returns ContentExpressionPlus
	 *
	 * Constraint:
	 *     element=TL_Ce_Recursive_ContentExpressionPlus_1_1_0
	 */
	protected void sequence_TL_Ce_Recursive(ISerializationContext context, ContentExpressionPlus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_PLUS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_PLUS__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionPlusElementAction_1_1_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TL_Ce_Recursive returns ContentExpressionStar
	 *
	 * Constraint:
	 *     element=TL_Ce_Recursive_ContentExpressionStar_1_0_0
	 */
	protected void sequence_TL_Ce_Recursive(ISerializationContext context, ContentExpressionStar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STAR__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.CONTENT_EXPRESSION_STAR__ELEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTL_Ce_RecursiveAccess().getContentExpressionStarElementAction_1_0_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Token returns Token
	 *
	 * Constraint:
	 *     (name=ID tokenRegex=STRING)
	 */
	protected void sequence_Token(ISerializationContext context, Token semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.ABSTRACT_TOKEN__NAME));
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.TOKEN__TOKEN_REGEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.TOKEN__TOKEN_REGEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTokenAccess().getTokenRegexSTRINGTerminalRuleCall_3_0(), semanticObject.getTokenRegex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransformationProgram returns TransformationProgram
	 *
	 * Constraint:
	 *     (delimiter=Delimiters? statements+=TLStatement+)
	 */
	protected void sequence_TransformationProgram(ISerializationContext context, TransformationProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TupleSelector returns TupleSelector
	 *
	 * Constraint:
	 *     (region=NodeExpression selectors+=Path_Expression selectors+=Path_Expression*)
	 */
	protected void sequence_TupleSelector(ISerializationContext context, TupleSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns CompoundTypeSpecifier
	 *
	 * Constraint:
	 *     (subtype=[Type|ID] index=INT?)
	 */
	protected void sequence_TypeSpecifier(ISerializationContext context, CompoundTypeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns ListTypeSpecifier
	 *
	 * Constraint:
	 *     index=INT
	 */
	protected void sequence_TypeSpecifier(ISerializationContext context, ListTypeSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SculptPackage.Literals.LIST_TYPE_SPECIFIER__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SculptPackage.Literals.LIST_TYPE_SPECIFIER__INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSpecifierAccess().getIndexINTTerminalRuleCall_1_2_0(), semanticObject.getIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns AtomicType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         base=STRING 
	 *         (
	 *             format=STRING | 
	 *             decimalChar=STRING | 
	 *             groupChar=STRING | 
	 *             length=INT | 
	 *             minLength=INT | 
	 *             maxLength=INT | 
	 *             minimum=STRING | 
	 *             maximum=STRING | 
	 *             minExclusive=STRING | 
	 *             maxExclusive=STRING | 
	 *             defaultValue=STRING | 
	 *             emptyValue=STRING
	 *         )*
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, AtomicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns CompoundType
	 *
	 * Constraint:
	 *     (name=ID primitives+=CompoundTypePrimitive* primitives+=CompoundTypePrimitive (defaultValue=STRING | emptyValue=STRING)*)
	 */
	protected void sequence_Type(ISerializationContext context, CompoundType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ListType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             base=[Type|ID] | 
	 *             minElements=INT | 
	 *             maxElements=INT | 
	 *             separator=STRING | 
	 *             defaultValue=STRING | 
	 *             emptyValue=STRING
	 *         )*
	 *     )
	 */
	protected void sequence_Type(ISerializationContext context, ListType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
